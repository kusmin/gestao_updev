
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">

				<option value="file0">github.com/kusmin/gestao_updev/backend/cmd/api/main.go (0.0%)</option>

				<option value="file1">github.com/kusmin/gestao_updev/backend/cmd/migrate/main.go (0.0%)</option>

				<option value="file2">github.com/kusmin/gestao_updev/backend/cmd/seed/main.go (0.0%)</option>

				<option value="file3">github.com/kusmin/gestao_updev/backend/docs/docs.go (100.0%)</option>

				<option value="file4">github.com/kusmin/gestao_updev/backend/internal/auth/jwt.go (52.2%)</option>

				<option value="file5">github.com/kusmin/gestao_updev/backend/internal/config/config.go (87.5%)</option>

				<option value="file6">github.com/kusmin/gestao_updev/backend/internal/http/contextutil/context.go (35.7%)</option>

				<option value="file7">github.com/kusmin/gestao_updev/backend/internal/http/handler/admin_products_handler.go (9.1%)</option>

				<option value="file8">github.com/kusmin/gestao_updev/backend/internal/http/handler/admin_users_handler.go (8.5%)</option>

				<option value="file9">github.com/kusmin/gestao_updev/backend/internal/http/handler/auth.go (0.0%)</option>

				<option value="file10">github.com/kusmin/gestao_updev/backend/internal/http/handler/bookings.go (0.0%)</option>

				<option value="file11">github.com/kusmin/gestao_updev/backend/internal/http/handler/catalog.go (0.0%)</option>

				<option value="file12">github.com/kusmin/gestao_updev/backend/internal/http/handler/clients.go (0.0%)</option>

				<option value="file13">github.com/kusmin/gestao_updev/backend/internal/http/handler/company.go (0.0%)</option>

				<option value="file14">github.com/kusmin/gestao_updev/backend/internal/http/handler/company_handler.go (12.0%)</option>

				<option value="file15">github.com/kusmin/gestao_updev/backend/internal/http/handler/dashboard.go (0.0%)</option>

				<option value="file16">github.com/kusmin/gestao_updev/backend/internal/http/handler/handler.go (36.8%)</option>

				<option value="file17">github.com/kusmin/gestao_updev/backend/internal/http/handler/inventory.go (0.0%)</option>

				<option value="file18">github.com/kusmin/gestao_updev/backend/internal/http/handler/professionals.go (0.0%)</option>

				<option value="file19">github.com/kusmin/gestao_updev/backend/internal/http/handler/sales.go (0.0%)</option>

				<option value="file20">github.com/kusmin/gestao_updev/backend/internal/http/handler/users.go (56.5%)</option>

				<option value="file21">github.com/kusmin/gestao_updev/backend/internal/http/response/response.go (100.0%)</option>

				<option value="file22">github.com/kusmin/gestao_updev/backend/internal/middleware/admin.go (6.2%)</option>

				<option value="file23">github.com/kusmin/gestao_updev/backend/internal/middleware/auth.go (64.0%)</option>

				<option value="file24">github.com/kusmin/gestao_updev/backend/internal/middleware/logging.go (87.2%)</option>

				<option value="file25">github.com/kusmin/gestao_updev/backend/internal/middleware/requestid.go (100.0%)</option>

				<option value="file26">github.com/kusmin/gestao_updev/backend/internal/middleware/tenant.go (93.3%)</option>

				<option value="file27">github.com/kusmin/gestao_updev/backend/internal/repository/company_repository.go (8.3%)</option>

				<option value="file28">github.com/kusmin/gestao_updev/backend/internal/repository/product_repository.go (0.0%)</option>

				<option value="file29">github.com/kusmin/gestao_updev/backend/internal/repository/repository.go (50.0%)</option>

				<option value="file30">github.com/kusmin/gestao_updev/backend/internal/server/server.go (24.8%)</option>

				<option value="file31">github.com/kusmin/gestao_updev/backend/internal/service/auth.go (0.0%)</option>

				<option value="file32">github.com/kusmin/gestao_updev/backend/internal/service/bookings.go (2.4%)</option>

				<option value="file33">github.com/kusmin/gestao_updev/backend/internal/service/catalog.go (54.8%)</option>

				<option value="file34">github.com/kusmin/gestao_updev/backend/internal/service/clients.go (0.0%)</option>

				<option value="file35">github.com/kusmin/gestao_updev/backend/internal/service/company.go (0.0%)</option>

				<option value="file36">github.com/kusmin/gestao_updev/backend/internal/service/company_service.go (4.5%)</option>

				<option value="file37">github.com/kusmin/gestao_updev/backend/internal/service/dashboard.go (0.0%)</option>

				<option value="file38">github.com/kusmin/gestao_updev/backend/internal/service/inventory.go (21.4%)</option>

				<option value="file39">github.com/kusmin/gestao_updev/backend/internal/service/professionals.go (0.0%)</option>

				<option value="file40">github.com/kusmin/gestao_updev/backend/internal/service/sales.go (5.7%)</option>

				<option value="file41">github.com/kusmin/gestao_updev/backend/internal/service/service.go (100.0%)</option>

				<option value="file42">github.com/kusmin/gestao_updev/backend/internal/service/users.go (18.0%)</option>

				<option value="file43">github.com/kusmin/gestao_updev/backend/pkg/database/database.go (0.0%)</option>

				<option value="file44">github.com/kusmin/gestao_updev/backend/pkg/logger/logger.go (100.0%)</option>

				<option value="file45">github.com/kusmin/gestao_updev/backend/pkg/telemetry/telemetry.go (0.0%)</option>

				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>

				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>

			</div>
		</div>
		<div id="content">

		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "log"
        "os"
        "os/signal"
        "syscall"

        "go.uber.org/zap"
        gormLogger "gorm.io/gorm/logger"

        "github.com/kusmin/gestao_updev/backend/internal/config"
        "github.com/kusmin/gestao_updev/backend/internal/server"
        "github.com/kusmin/gestao_updev/backend/pkg/database"
        "github.com/kusmin/gestao_updev/backend/pkg/logger"
        "github.com/kusmin/gestao_updev/backend/pkg/telemetry"
)

// @title Gestão UpDev API
// @version 1.0
// @description API para a plataforma de gestão de comércios locais.
// @contact.name API Support
// @contact.email support@updev.com
// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html
// @host localhost:8080
// @BasePath /v1
// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
// @description Token JWT no formato `Bearer &lt;token&gt;`
// @securityDefinitions.apikey TenantHeader
// @in header
// @name X-Tenant-ID
func main() <span class="cov0" title="0">{
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("load config: %v", err)
        }</span>

        <span class="cov0" title="0">zapLogger, err := logger.New(cfg.LogLevel)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("init logger: %v", err)
        }</span>
        <span class="cov0" title="0">defer zapLogger.Sync()

        ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
        defer stop()

        tel, err := telemetry.Init(ctx, telemetry.Config{
                ServiceName:   cfg.ServiceName,
                Environment:   cfg.AppEnv,
                EnableTracing: cfg.TelemetryEnabled,
                OTLPEndpoint:  cfg.OTLPEndpoint,
                OTLPHeaders:   cfg.OTLPHeaders,
                OTLPInsecure:  cfg.OTLPInsecure,
        })
        if err != nil </span><span class="cov0" title="0">{
                zapLogger.Fatal("failed to initialize telemetry", zap.Error(err))
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := tel.Shutdown(context.Background()); err != nil </span><span class="cov0" title="0">{
                        zapLogger.Warn("error shutting down telemetry", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">db, err := database.New(database.Config{
                URL:             cfg.DatabaseURL,
                MaxIdleConns:    cfg.DBMaxIdleConns,
                MaxOpenConns:    cfg.DBMaxOpenConns,
                ConnMaxLifetime: cfg.DBConnMaxLifetime,
                LogMode:         mapGormLogLevel(cfg.LogLevel),
        })
        if err != nil </span><span class="cov0" title="0">{
                zapLogger.Fatal("failed to initialize database", zap.Error(err))
        }</span>
        <span class="cov0" title="0">sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                zapLogger.Fatal("failed to expose database handle", zap.Error(err))
        }</span>
        <span class="cov0" title="0">defer sqlDB.Close()

        srv := server.New(cfg, zapLogger, db, tel)

        if err := srv.Run(ctx); err != nil </span><span class="cov0" title="0">{
                zapLogger.Fatal("server stopped with error", zap.Any("error", err))
        }</span>
}

func mapGormLogLevel(level string) gormLogger.LogLevel <span class="cov0" title="0">{
        switch level </span>{
        case "debug":<span class="cov0" title="0">
                return gormLogger.Info</span>
        case "warn":<span class="cov0" title="0">
                return gormLogger.Warn</span>
        case "error":<span class="cov0" title="0">
                return gormLogger.Error</span>
        default:<span class="cov0" title="0">
                return gormLogger.Silent</span>
        }
}
</pre>

		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "os"
        "path/filepath"
        "sort"
        "strings"
        "time"

        "gorm.io/gorm"

        "github.com/kusmin/gestao_updev/backend/internal/config"
        "github.com/kusmin/gestao_updev/backend/pkg/database"
)

type migrationFile struct {
        Version string
        Path    string
        Name    string
}

func main() <span class="cov0" title="0">{
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("load config: %v", err)
        }</span>

        <span class="cov0" title="0">db, err := database.New(database.Config{
                URL:             cfg.DatabaseURL,
                MaxIdleConns:    cfg.DBMaxIdleConns,
                MaxOpenConns:    cfg.DBMaxOpenConns,
                ConnMaxLifetime: cfg.DBConnMaxLifetime,
                LogMode:         0,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("connect db: %v", err)
        }</span>
        <span class="cov0" title="0">sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("expose db: %v", err)
        }</span>
        <span class="cov0" title="0">defer sqlDB.Close()

        ctx := context.Background()
        if err := applyMigrations(ctx, db); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("apply migrations: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("Migrations applied successfully.")</span>
}

func applyMigrations(ctx context.Context, db *gorm.DB) error <span class="cov0" title="0">{
        if err := db.WithContext(ctx).
                Exec(`CREATE TABLE IF NOT EXISTS schema_migrations (
                        version TEXT PRIMARY KEY,
                        applied_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
                )`).
                Error; err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create schema_migrations: %w", err)
        }</span>

        <span class="cov0" title="0">files, err := os.ReadDir("migrations")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("read migrations dir: %w", err)
        }</span>

        <span class="cov0" title="0">var migrations []migrationFile
        for _, file := range files </span><span class="cov0" title="0">{
                if file.IsDir() || !strings.HasSuffix(file.Name(), ".up.sql") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">version := strings.SplitN(file.Name(), "_", 2)[0]
                migrations = append(migrations, migrationFile{
                        Version: version,
                        Path:    filepath.Join("migrations", file.Name()),
                        Name:    file.Name(),
                })</span>
        }

        <span class="cov0" title="0">sort.Slice(migrations, func(i, j int) bool </span><span class="cov0" title="0">{
                return migrations[i].Version &lt; migrations[j].Version
        }</span>)

        <span class="cov0" title="0">for _, m := range migrations </span><span class="cov0" title="0">{
                applied, err := isMigrationApplied(ctx, db, m.Version)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if applied </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">log.Printf("Applying migration %s...", m.Name)
                contents, err := os.ReadFile(m.Path)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("read migration %s: %w", m.Name, err)
                }</span>

                <span class="cov0" title="0">if err := db.WithContext(ctx).Exec(string(contents)).Error; err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("execute migration %s: %w", m.Name, err)
                }</span>

                <span class="cov0" title="0">if err := db.WithContext(ctx).
                        Exec("INSERT INTO schema_migrations (version, applied_at) VALUES (?, ?)", m.Version, time.Now()).
                        Error; err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("record migration %s: %w", m.Name, err)
                }</span>
                <span class="cov0" title="0">log.Printf("Migration %s applied.", m.Name)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func isMigrationApplied(ctx context.Context, db *gorm.DB, version string) (bool, error) <span class="cov0" title="0">{
        var count int64
        if err := db.WithContext(ctx).
                Raw("SELECT COUNT(1) FROM schema_migrations WHERE version = ?", version).
                Scan(&amp;count).Error; err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("check migration %s: %w", version, err)
        }</span>
        <span class="cov0" title="0">return count &gt; 0, nil</span>
}
</pre>

		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "log"

        "golang.org/x/crypto/bcrypt"
        "gorm.io/gorm"
        "gorm.io/gorm/clause"

        "github.com/kusmin/gestao_updev/backend/internal/config"
        "github.com/kusmin/gestao_updev/backend/internal/domain"
        "github.com/kusmin/gestao_updev/backend/pkg/database"
)

const (
        demoDocument = "00000000000191"
        demoEmail    = "admin@updev.demo"
        demoPassword = "Admin@123"
)

func main() <span class="cov0" title="0">{
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("load config: %v", err)
        }</span>

        <span class="cov0" title="0">db, err := database.New(database.Config{
                URL:             cfg.DatabaseURL,
                MaxIdleConns:    cfg.DBMaxIdleConns,
                MaxOpenConns:    cfg.DBMaxOpenConns,
                ConnMaxLifetime: cfg.DBConnMaxLifetime,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("connect db: %v", err)
        }</span>
        <span class="cov0" title="0">sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("expose db: %v", err)
        }</span>
        <span class="cov0" title="0">defer sqlDB.Close()

        if err := runSeed(context.Background(), db); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("seed data: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("Seed executado com sucesso.")</span>
}

func runSeed(ctx context.Context, db *gorm.DB) error <span class="cov0" title="0">{
        var company domain.Company
        err := db.WithContext(ctx).Where("document = ?", demoDocument).First(&amp;company).Error
        if err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        company = domain.Company{
                                Name:     "UpDev Demo",
                                Document: demoDocument,
                                Timezone: "America/Sao_Paulo",
                        }
                        if err := db.WithContext(ctx).Create(&amp;company).Error; err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        return err
                }</span>
        }

        <span class="cov0" title="0">if err := ensureAdminUser(ctx, db, company); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := ensureClient(ctx, db, company); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := ensureService(ctx, db, company); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := ensureProduct(ctx, db, company); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func ensureAdminUser(ctx context.Context, db *gorm.DB, company domain.Company) error <span class="cov0" title="0">{
        var user domain.User
        err := db.WithContext(ctx).Where("tenant_id = ? AND email = ?", company.ID, demoEmail).First(&amp;user).Error
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if err != gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">hash, err := bcrypt.GenerateFromPassword([]byte(demoPassword), 12)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">user = domain.User{
                TenantModel:  domain.TenantModel{TenantID: company.ID},
                Name:         "Admin Demo",
                Email:        demoEmail,
                Role:         "admin",
                Phone:        "+55 11 99999-0000",
                PasswordHash: string(hash),
                Active:       true,
        }
        return db.WithContext(ctx).Create(&amp;user).Error</span>
}

func ensureClient(ctx context.Context, db *gorm.DB, company domain.Company) error <span class="cov0" title="0">{
        client := domain.Client{
                TenantModel: domain.TenantModel{TenantID: company.ID},
                Name:        "Cliente Demo",
                Email:       "cliente@demo.com",
                Phone:       "+55 11 98888-0000",
        }
        return db.WithContext(ctx).
                Clauses(clause.OnConflict{
                        Columns:   []clause.Column{{Name: "tenant_id"}, {Name: "email"}},
                        UpdateAll: false,
                }).
                Create(&amp;client).Error
}</span>

func ensureService(ctx context.Context, db *gorm.DB, company domain.Company) error <span class="cov0" title="0">{
        service := domain.Service{
                TenantModel:     domain.TenantModel{TenantID: company.ID},
                Name:            "Corte Premium",
                Category:        "Barbearia",
                Description:     "Corte com acabamento e massagem.",
                DurationMinutes: 45,
                Price:           60,
                Color:           "#ff9900",
        }
        return db.WithContext(ctx).
                Clauses(clause.OnConflict{
                        Columns:   []clause.Column{{Name: "tenant_id"}, {Name: "name"}},
                        UpdateAll: false,
                }).
                Create(&amp;service).Error
}</span>

func ensureProduct(ctx context.Context, db *gorm.DB, company domain.Company) error <span class="cov0" title="0">{
        product := domain.Product{
                TenantModel: domain.TenantModel{TenantID: company.ID},
                Name:        "Pomada Modeladora",
                SKU:         "POM-001",
                Price:       35,
                Cost:        18,
                StockQty:    50,
                MinStock:    5,
                Description: "Pomada de fixação média.",
        }
        return db.WithContext(ctx).
                Clauses(clause.OnConflict{
                        Columns:   []clause.Column{{Name: "tenant_id"}, {Name: "sku"}},
                        UpdateAll: false,
                }).
                Create(&amp;product).Error
}</span>
</pre>

		<pre class="file" id="file3" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {
            "name": "API Support",
            "email": "support@updev.com"
        },
        "license": {
            "name": "Apache 2.0",
            "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/auth/login": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "Autentica usuário",
                "parameters": [
                    {
                        "description": "Credenciais",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.LoginRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    }
                }
            }
        },
        "/auth/refresh": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "Atualiza tokens de acesso",
                "parameters": [
                    {
                        "description": "Refresh token",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.RefreshRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    }
                }
            }
        },
        "/auth/signup": {
            "post": {
                "description": "Fluxo inicial da plataforma: cria empresa, usuário admin e retorna tokens.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "Cria empresa e usuário administrador",
                "parameters": [
                    {
                        "description": "Dados do signup",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.SignupRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    }
                }
            }
        },
        "/bookings": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "TenantHeader": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Bookings"
                ],
                "summary": "Lista agendamentos",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Data (YYYY-MM-DD)",
                        "name": "date",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Profissional",
                        "name": "professional_id",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Status",
                        "name": "status",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "TenantHeader": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Bookings"
                ],
                "summary": "Cria agendamento",
                "parameters": [
                    {
                        "description": "Agendamento",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.BookingRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    }
                }
            }
        },
        "/bookings/{id}": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "TenantHeader": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Bookings"
                ],
                "summary": "Atualiza agendamento",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Booking ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Campos editáveis",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.BookingUpdateRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    }
                }
            }
        },
        "/bookings/{id}/cancel": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "TenantHeader": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Bookings"
                ],
                "summary": "Cancela agendamento",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Booking ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Motivo",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.BookingCancelRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    }
                }
            }
        },
        "/clients": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "TenantHeader": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Clients"
                ],
                "summary": "Lista clientes",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Filtro por nome/email/telefone",
                        "name": "search",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Lista de tags separadas por vírgula",
                        "name": "tags",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "default": 1,
                        "description": "Página",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "default": 20,
                        "description": "Itens por página",
                        "name": "per_page",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "TenantHeader": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Clients"
                ],
                "summary": "Cria cliente",
                "parameters": [
                    {
                        "description": "Cliente",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.ClientRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    }
                }
            }
        },
        "/clients/{id}": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "TenantHeader": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Clients"
                ],
                "summary": "Busca cliente",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Client ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "TenantHeader": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Clients"
                ],
                "summary": "Atualiza cliente",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Client ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Cliente",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.ClientRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "TenantHeader": []
                    }
                ],
                "tags": [
                    "Clients"
                ],
                "summary": "Remove cliente",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Client ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    }
                }
            }
        },
        "/companies/me": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "TenantHeader": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Company"
                ],
                "summary": "Retorna dados da empresa atual",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "TenantHeader": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Company"
                ],
                "summary": "Atualiza dados da empresa atual",
                "parameters": [
                    {
                        "description": "Campos editáveis",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.CompanyUpdateRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    }
                }
            }
        },
        "/dashboard/daily": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "TenantHeader": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Dashboard"
                ],
                "summary": "KPIs diários",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Data (YYYY-MM-DD)",
                        "name": "date",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Profissional",
                        "name": "professional_id",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    }
                }
            }
        },
        "/inventory/movements": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "TenantHeader": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Inventory"
                ],
                "summary": "Lista movimentações de estoque",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Filtro por produto",
                        "name": "product_id",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Tipo (in|out|adjustment)",
                        "name": "type",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Data inicial (RFC3339)",
                        "name": "start_date",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Data final (RFC3339)",
                        "name": "end_date",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "TenantHeader": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Inventory"
                ],
                "summary": "Registra movimento de estoque",
                "parameters": [
                    {
                        "description": "Movimentação",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.InventoryRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    }
                }
            }
        },
        "/payments": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "TenantHeader": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Payments"
                ],
                "summary": "Lista pagamentos",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Método",
                        "name": "method",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Data inicial RFC3339",
                        "name": "start_date",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Data final RFC3339",
                        "name": "end_date",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    }
                }
            }
        },
        "/products": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "TenantHeader": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Products"
                ],
                "summary": "Lista produtos",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "TenantHeader": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Products"
                ],
                "summary": "Cria produto",
                "parameters": [
                    {
                        "description": "Produto",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.ProductRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    }
                }
            }
        },
        "/products/{id}": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "TenantHeader": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Products"
                ],
                "summary": "Busca produto por ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Product ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "TenantHeader": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Products"
                ],
                "summary": "Atualiza produto",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Product ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Produto",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.ProductRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "TenantHeader": []
                    }
                ],
                "tags": [
                    "Products"
                ],
                "summary": "Remove produto",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Product ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    }
                }
            }
        },
        "/professionals": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "TenantHeader": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Professionals"
                ],
                "summary": "Lista profissionais ativos",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    }
                }
            }
        },
        "/sales/orders": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "TenantHeader": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Sales"
                ],
                "summary": "Lista pedidos/vendas",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Status",
                        "name": "status",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Cliente",
                        "name": "client_id",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Data (YYYY-MM-DD)",
                        "name": "date",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "TenantHeader": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Sales"
                ],
                "summary": "Cria pedido/venda",
                "parameters": [
                    {
                        "description": "Pedido",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.SalesOrderRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    }
                }
            }
        },
        "/sales/orders/{id}": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "TenantHeader": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Sales"
                ],
                "summary": "Atualiza pedido",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Order ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Campos editáveis",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.SalesOrderUpdateRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    }
                }
            }
        },
        "/sales/orders/{id}/payments": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "TenantHeader": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Payments"
                ],
                "summary": "Registra pagamento",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Order ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Pagamento",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.PaymentRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    }
                }
            }
        },
        "/services": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "TenantHeader": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Services"
                ],
                "summary": "Lista serviços",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "TenantHeader": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Services"
                ],
                "summary": "Cria serviço",
                "parameters": [
                    {
                        "description": "Serviço",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.ServiceRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    }
                }
            }
        },
        "/services/{id}": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "TenantHeader": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Services"
                ],
                "summary": "Busca serviço por ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Service ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "TenantHeader": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Services"
                ],
                "summary": "Atualiza serviço",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Service ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Serviço",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.ServiceRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "TenantHeader": []
                    }
                ],
                "tags": [
                    "Services"
                ],
                "summary": "Remove serviço",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Service ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    }
                }
            }
        },
        "/users": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "TenantHeader": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Users"
                ],
                "summary": "Lista usuários do tenant",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Filtro por role",
                        "name": "role",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "default": 1,
                        "description": "Página",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "default": 20,
                        "description": "Itens por página",
                        "name": "per_page",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "TenantHeader": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Users"
                ],
                "summary": "Cria um usuário",
                "parameters": [
                    {
                        "description": "Novo usuário",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.CreateUserRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    }
                }
            }
        },
        "/users/{id}": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "TenantHeader": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Users"
                ],
                "summary": "Busca usuário por ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "TenantHeader": []
                    }
                ],
                "tags": [
                    "Users"
                ],
                "summary": "Remove (soft delete) um usuário",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    }
                }
            },
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "TenantHeader": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Users"
                ],
                "summary": "Atualiza parcialmente um usuário",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Campos editáveis",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.UpdateUserRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/response.APIResponse"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "handler.BookingCancelRequest": {
            "type": "object",
            "properties": {
                "reason": {
                    "type": "string"
                }
            }
        },
        "handler.BookingRequest": {
            "type": "object",
            "required": [
                "client_id",
                "professional_id",
                "service_id",
                "start_at"
            ],
            "properties": {
                "client_id": {
                    "type": "string"
                },
                "end_at": {
                    "type": "string"
                },
                "notes": {
                    "type": "string"
                },
                "professional_id": {
                    "type": "string"
                },
                "service_id": {
                    "type": "string"
                },
                "start_at": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                }
            }
        },
        "handler.BookingUpdateRequest": {
            "type": "object",
            "properties": {
                "end_at": {
                    "type": "string"
                },
                "notes": {
                    "type": "string"
                },
                "start_at": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                }
            }
        },
        "handler.ClientRequest": {
            "type": "object",
            "required": [
                "name"
            ],
            "properties": {
                "contact": {
                    "type": "object",
                    "additionalProperties": true
                },
                "email": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "notes": {
                    "type": "string"
                },
                "phone": {
                    "type": "string"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "handler.CompanyUpdateRequest": {
            "type": "object",
            "properties": {
                "email": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "phone": {
                    "type": "string"
                },
                "settings": {
                    "type": "object",
                    "additionalProperties": true
                },
                "timezone": {
                    "type": "string"
                }
            }
        },
        "handler.CreateUserRequest": {
            "type": "object",
            "required": [
                "email",
                "name",
                "password",
                "role"
            ],
            "properties": {
                "email": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "password": {
                    "type": "string",
                    "minLength": 8
                },
                "phone": {
                    "type": "string"
                },
                "role": {
                    "type": "string"
                }
            }
        },
        "handler.InventoryRequest": {
            "type": "object",
            "required": [
                "product_id",
                "quantity",
                "type"
            ],
            "properties": {
                "order_id": {
                    "type": "string"
                },
                "product_id": {
                    "type": "string"
                },
                "quantity": {
                    "type": "integer"
                },
                "reason": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                }
            }
        },
        "handler.LoginRequest": {
            "type": "object",
            "required": [
                "email",
                "password"
            ],
            "properties": {
                "email": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                }
            }
        },
        "handler.PaymentRequest": {
            "type": "object",
            "required": [
                "amount",
                "method",
                "paid_at"
            ],
            "properties": {
                "amount": {
                    "type": "number"
                },
                "details": {
                    "type": "object",
                    "additionalProperties": true
                },
                "method": {
                    "type": "string"
                },
                "paid_at": {
                    "type": "string"
                }
            }
        },
        "handler.ProductRequest": {
            "type": "object",
            "required": [
                "name",
                "price",
                "sku"
            ],
            "properties": {
                "cost": {
                    "type": "number"
                },
                "description": {
                    "type": "string"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true
                },
                "min_stock": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                },
                "price": {
                    "type": "number"
                },
                "sku": {
                    "type": "string"
                },
                "stock_qty": {
                    "type": "integer"
                }
            }
        },
        "handler.RefreshRequest": {
            "type": "object",
            "required": [
                "refresh_token"
            ],
            "properties": {
                "refresh_token": {
                    "type": "string"
                }
            }
        },
        "handler.SalesOrderItemRequest": {
            "type": "object",
            "required": [
                "quantity",
                "ref_id",
                "type",
                "unit_price"
            ],
            "properties": {
                "quantity": {
                    "type": "integer"
                },
                "ref_id": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                },
                "unit_price": {
                    "type": "number"
                }
            }
        },
        "handler.SalesOrderRequest": {
            "type": "object",
            "required": [
                "client_id",
                "items"
            ],
            "properties": {
                "booking_id": {
                    "type": "string"
                },
                "client_id": {
                    "type": "string"
                },
                "discount": {
                    "type": "number"
                },
                "items": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/handler.SalesOrderItemRequest"
                    }
                },
                "notes": {
                    "type": "string"
                }
            }
        },
        "handler.SalesOrderUpdateRequest": {
            "type": "object",
            "properties": {
                "notes": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                }
            }
        },
        "handler.ServiceRequest": {
            "type": "object",
            "required": [
                "duration_minutes",
                "name",
                "price"
            ],
            "properties": {
                "category": {
                    "type": "string"
                },
                "color": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "duration_minutes": {
                    "type": "integer"
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true
                },
                "name": {
                    "type": "string"
                },
                "price": {
                    "type": "number"
                }
            }
        },
        "handler.SignupRequest": {
            "type": "object",
            "required": [
                "company",
                "user"
            ],
            "properties": {
                "company": {
                    "type": "object",
                    "required": [
                        "name"
                    ],
                    "properties": {
                        "document": {
                            "type": "string"
                        },
                        "name": {
                            "type": "string"
                        },
                        "phone": {
                            "type": "string"
                        }
                    }
                },
                "user": {
                    "type": "object",
                    "required": [
                        "email",
                        "name",
                        "password"
                    ],
                    "properties": {
                        "email": {
                            "type": "string"
                        },
                        "name": {
                            "type": "string"
                        },
                        "password": {
                            "type": "string",
                            "minLength": 8
                        },
                        "phone": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "handler.UpdateUserRequest": {
            "type": "object",
            "properties": {
                "active": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                },
                "phone": {
                    "type": "string"
                },
                "role": {
                    "type": "string"
                }
            }
        },
        "response.APIResponse": {
            "type": "object",
            "properties": {
                "data": {},
                "error": {},
                "meta": {}
            }
        }
    },
    "securityDefinitions": {
        "BearerAuth": {
            "description": "Token JWT no formato ` + "`" + `Bearer \u003ctoken\u003e` + "`" + `",
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        },
        "TenantHeader": {
            "type": "apiKey",
            "name": "X-Tenant-ID",
            "in": "header"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:8080",
        BasePath:         "/v1",
        Schemes:          []string{},
        Title:            "Gestão UpDev API",
        Description:      "API para a plataforma de gestão de comércios locais.",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov8" title="1">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>

		<pre class="file" id="file4" style="display: none">package auth

import (
        "time"

        jwt "github.com/golang-jwt/jwt/v5"
)

// Claims representa os dados adicionais embutidos no token.
type Claims struct {
        UserID   string `json:"user_id"`
        TenantID string `json:"tenant_id"`
        Role     string `json:"role"`
        jwt.RegisteredClaims
}

// TokenPair agrupa access + refresh tokens.
type TokenPair struct {
        AccessToken  string `json:"access_token"`
        RefreshToken string `json:"refresh_token"`
        ExpiresIn    int64  `json:"expires_in"`
}

// JWTManager encapsula geração e validação de tokens.
type JWTManager struct {
        accessSecret  []byte
        refreshSecret []byte
        accessTTL     time.Duration
        refreshTTL    time.Duration
}

// NewJWTManager cria o gerador/validador padrão.
func NewJWTManager(accessSecret, refreshSecret string, accessTTL, refreshTTL time.Duration) *JWTManager <span class="cov10" title="9">{
        return &amp;JWTManager{
                accessSecret:  []byte(accessSecret),
                refreshSecret: []byte(refreshSecret),
                accessTTL:     accessTTL,
                refreshTTL:    refreshTTL,
        }
}</span>

// GenerateTokens devolve o par access/refresh.
func (m *JWTManager) GenerateTokens(userID, tenantID, role string) (*TokenPair, error) <span class="cov0" title="0">{
        access, err := m.GenerateAccessToken(userID, tenantID, role)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">refresh, err := m.GenerateRefreshToken(userID, tenantID, role)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;TokenPair{
                AccessToken:  access,
                RefreshToken: refresh,
                ExpiresIn:    int64(m.accessTTL.Seconds()),
        }, nil</span>
}

// GenerateAccessToken cria um token de curta duração.
func (m *JWTManager) GenerateAccessToken(userID, tenantID, role string) (string, error) <span class="cov6" title="4">{
        return m.generateToken(userID, tenantID, role, m.accessTTL, m.accessSecret)
}</span>

// GenerateRefreshToken cria um token de renovação.
func (m *JWTManager) GenerateRefreshToken(userID, tenantID, role string) (string, error) <span class="cov0" title="0">{
        return m.generateToken(userID, tenantID, role, m.refreshTTL, m.refreshSecret)
}</span>

func (m *JWTManager) generateToken(userID, tenantID, role string, ttl time.Duration, secret []byte) (string, error) <span class="cov6" title="4">{
        now := time.Now()
        claims := &amp;Claims{
                UserID:   userID,
                TenantID: tenantID,
                Role:     role,
                RegisteredClaims: jwt.RegisteredClaims{
                        IssuedAt:  jwt.NewNumericDate(now),
                        ExpiresAt: jwt.NewNumericDate(now.Add(ttl)),
                },
        }
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString(secret)
}</span>

// ValidateAccessToken valida e extrai as claims do access token.
func (m *JWTManager) ValidateAccessToken(token string) (*Claims, error) <span class="cov9" title="8">{
        return m.parseClaims(token, m.accessSecret)
}</span>

// ValidateRefreshToken valida e extrai as claims do refresh token.
func (m *JWTManager) ValidateRefreshToken(token string) (*Claims, error) <span class="cov0" title="0">{
        return m.parseClaims(token, m.refreshSecret)
}</span>

func (m *JWTManager) parseClaims(token string, secret []byte) (*Claims, error) <span class="cov9" title="8">{
        parsed, err := jwt.ParseWithClaims(token, &amp;Claims{}, func(t *jwt.Token) (interface{}, error) </span><span class="cov9" title="8">{
                return secret, nil
        }</span>)
        <span class="cov9" title="8">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov9" title="8">if claims, ok := parsed.Claims.(*Claims); ok &amp;&amp; parsed.Valid </span><span class="cov9" title="8">{
                return claims, nil
        }</span>
        <span class="cov0" title="0">return nil, jwt.ErrTokenInvalidClaims</span>
}
</pre>

		<pre class="file" id="file5" style="display: none">package config

import (
        "fmt"
        "strings"
        "time"

        env "github.com/caarlos0/env/v11"
)

const (
        defaultDatabaseURL      = "postgres://postgres:postgres@localhost:5432/gestao_updev?sslmode=disable"
        defaultJWTAccessSecret  = "dev-access-secret"
        defaultJWTRefreshSecret = "dev-refresh-secret"
)

// Config centraliza parâmetros de execução do backend.
type Config struct {
        AppEnv             string        `env:"APP_ENV" envDefault:"development"`
        ServiceName        string        `env:"SERVICE_NAME" envDefault:"gestao-api"`
        HTTPPort           int           `env:"HTTP_PORT" envDefault:"8080"`
        TenantHeader       string        `env:"TENANT_HEADER" envDefault:"X-Tenant-ID"`
        LogLevel           string        `env:"LOG_LEVEL" envDefault:"info"`
        DatabaseURL        string        `env:"DATABASE_URL"`
        DBMaxIdleConns     int           `env:"DB_MAX_IDLE_CONNS" envDefault:"5"`
        DBMaxOpenConns     int           `env:"DB_MAX_OPEN_CONNS" envDefault:"20"`
        DBConnMaxLifetime  time.Duration `env:"DB_CONN_MAX_LIFETIME" envDefault:"1h"`
        JWTAccessSecret    string        `env:"JWT_ACCESS_SECRET"`
        JWTRefreshSecret   string        `env:"JWT_REFRESH_SECRET"`
        JWTAccessTTL       time.Duration `env:"JWT_ACCESS_TTL" envDefault:"15m"`
        JWTRefreshTTL      time.Duration `env:"JWT_REFRESH_TTL" envDefault:"720h"`
        BcryptCost         int           `env:"BCRYPT_COST" envDefault:"12"`
        RefreshTokenLength int           `env:"REFRESH_TOKEN_LENGTH" envDefault:"64"`
        TelemetryEnabled   bool          `env:"OTEL_ENABLED" envDefault:"false"`
        OTLPEndpoint       string        `env:"OTEL_EXPORTER_OTLP_ENDPOINT"`
        OTLPHeaders        string        `env:"OTEL_EXPORTER_OTLP_HEADERS"`
        OTLPInsecure       bool          `env:"OTEL_EXPORTER_OTLP_INSECURE" envDefault:"false"`
        MetricsRoute       string        `env:"METRICS_ROUTE" envDefault:"/metrics"`
}

// Load lê variáveis de ambiente e monta a configuração.
func Load() (*Config, error) <span class="cov10" title="6">{
        cfg := &amp;Config{}
        if err := env.Parse(cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse env config: %w", err)
        }</span>
        <span class="cov10" title="6">if err := cfg.ensureProtectedValues(); err != nil </span><span class="cov7" title="4">{
                return nil, err
        }</span>
        <span class="cov4" title="2">return cfg, nil</span>
}

// Address retorna host:port para o servidor HTTP.
func (c *Config) Address() string <span class="cov1" title="1">{
        return fmt.Sprintf(":%d", c.HTTPPort)
}</span>

func (c *Config) ensureProtectedValues() error <span class="cov10" title="6">{
        isProd := strings.EqualFold(c.AppEnv, "production")

        switch </span>{
        case c.DatabaseURL == "":<span class="cov4" title="2">
                if isProd </span><span class="cov1" title="1">{
                        return fmt.Errorf("DATABASE_URL must be defined in production")
                }</span>
                <span class="cov1" title="1">c.DatabaseURL = defaultDatabaseURL</span>
        case isProd &amp;&amp; c.DatabaseURL == defaultDatabaseURL:<span class="cov1" title="1">
                return fmt.Errorf("DATABASE_URL must not use the development default in production")</span>
        }

        <span class="cov7" title="4">switch </span>{
        case c.JWTAccessSecret == "":<span class="cov1" title="1">
                if isProd </span><span class="cov0" title="0">{
                        return fmt.Errorf("JWT_ACCESS_SECRET must be defined in production")
                }</span>
                <span class="cov1" title="1">c.JWTAccessSecret = defaultJWTAccessSecret</span>
        case isProd &amp;&amp; c.JWTAccessSecret == defaultJWTAccessSecret:<span class="cov1" title="1">
                return fmt.Errorf("JWT_ACCESS_SECRET must not use the development default in production")</span>
        }

        <span class="cov6" title="3">switch </span>{
        case c.JWTRefreshSecret == "":<span class="cov4" title="2">
                if isProd </span><span class="cov1" title="1">{
                        return fmt.Errorf("JWT_REFRESH_SECRET must be defined in production")
                }</span>
                <span class="cov1" title="1">c.JWTRefreshSecret = defaultJWTRefreshSecret</span>
        case isProd &amp;&amp; c.JWTRefreshSecret == defaultJWTRefreshSecret:<span class="cov0" title="0">
                return fmt.Errorf("JWT_REFRESH_SECRET must not use the development default in production")</span>
        }

        <span class="cov4" title="2">return nil</span>
}
</pre>

		<pre class="file" id="file6" style="display: none">package contextutil

import (
        "fmt"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"

        "github.com/kusmin/gestao_updev/backend/internal/middleware"
)

// TenantID extrai o tenant_id do contexto.
func TenantID(c *gin.Context) (uuid.UUID, error) <span class="cov10" title="8">{
        value, exists := c.Get(middleware.ContextTenantIDKey)
        if !exists </span><span class="cov0" title="0">{
                return uuid.Nil, fmt.Errorf("tenant_id not found in context")
        }</span>
        <span class="cov10" title="8">tenantStr, ok := value.(string)
        if !ok </span><span class="cov0" title="0">{
                return uuid.Nil, fmt.Errorf("tenant_id inválido")
        }</span>
        <span class="cov10" title="8">return uuid.Parse(tenantStr)</span>
}

// UserID extrai o identificador do usuário autenticado.
func UserID(c *gin.Context) (uuid.UUID, error) <span class="cov0" title="0">{
        value, exists := c.Get(middleware.ContextUserIDKey)
        if !exists </span><span class="cov0" title="0">{
                return uuid.Nil, fmt.Errorf("user_id not found in context")
        }</span>
        <span class="cov0" title="0">userStr, ok := value.(string)
        if !ok </span><span class="cov0" title="0">{
                return uuid.Nil, fmt.Errorf("user_id inválido")
        }</span>
        <span class="cov0" title="0">return uuid.Parse(userStr)</span>
}
</pre>

		<pre class="file" id="file7" style="display: none">package handler

import (
        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/kusmin/gestao_updev/backend/internal/service"
        "net/http"
)

func (h *API) RegisterAdminProductRoutes(router *gin.RouterGroup) <span class="cov10" title="2">{
        router.GET("/products", h.ListAllProducts)
        router.POST("/products", h.AdminCreateProduct)
        router.PUT("/products/:id", h.AdminUpdateProduct)
        router.DELETE("/products/:id", h.AdminDeleteProduct)
}</span>

func (h *API) ListAllProducts(c *gin.Context) <span class="cov0" title="0">{
        products, err := h.svc.ListAllProducts(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"data": products})</span>
}

type AdminCreateProductInput struct {
        service.ProductInput
        TenantID string `json:"tenant_id" binding:"required"`
}

func (h *API) AdminCreateProduct(c *gin.Context) <span class="cov0" title="0">{
        var input AdminCreateProductInput
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">tenantID, err := uuid.Parse(input.TenantID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid tenant_id"})
                return
        }</span>

        <span class="cov0" title="0">adminInput := service.AdminProductInput{
                ProductInput: input.ProductInput,
                TenantID:     tenantID,
        }

        product, err := h.svc.AdminCreateProduct(c.Request.Context(), adminInput)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{"data": product})</span>
}

func (h *API) AdminUpdateProduct(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid id"})
                return
        }</span>

        <span class="cov0" title="0">var input service.ProductInput
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">product, err := h.svc.AdminUpdateProduct(c.Request.Context(), id, input)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"data": product})</span>
}

func (h *API) AdminDeleteProduct(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid id"})
                return
        }</span>

        <span class="cov0" title="0">if err := h.svc.AdminDeleteProduct(c.Request.Context(), id); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}
</pre>

		<pre class="file" id="file8" style="display: none">package handler

import (
        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/kusmin/gestao_updev/backend/internal/service"
        "net/http"
        "strconv"
)

func (h *API) RegisterAdminUserRoutes(router *gin.RouterGroup) <span class="cov10" title="2">{
        router.GET("/users", h.ListAllUsers)
        router.POST("/users", h.AdminCreateUser)
        router.PUT("/users/:id", h.AdminUpdateUser)
        router.DELETE("/users/:id", h.AdminDeleteUser)
}</span>

func (h *API) ListAllUsers(c *gin.Context) <span class="cov0" title="0">{
        page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        perPage, _ := strconv.Atoi(c.DefaultQuery("per_page", "20"))
        role := c.Query("role")

        filter := service.UsersFilter{
                Role:    role,
                Page:    page,
                PerPage: perPage,
        }

        users, _, err := h.svc.ListAllUsers(c.Request.Context(), filter)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"data": users})</span>
}

type AdminCreateUserInput struct {
        service.CreateUserInput
        TenantID string `json:"tenant_id" binding:"required"`
}

func (h *API) AdminCreateUser(c *gin.Context) <span class="cov0" title="0">{
        var input AdminCreateUserInput
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">tenantID, err := uuid.Parse(input.TenantID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid tenant_id"})
                return
        }</span>

        <span class="cov0" title="0">user, err := h.svc.AdminCreateUser(c.Request.Context(), input.CreateUserInput, tenantID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{"data": user})</span>
}

func (h *API) AdminUpdateUser(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid id"})
                return
        }</span>

        <span class="cov0" title="0">var input service.UpdateUserInput
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">user, err := h.svc.AdminUpdateUser(c.Request.Context(), id, input)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"data": user})</span>
}

func (h *API) AdminDeleteUser(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid id"})
                return
        }</span>

        <span class="cov0" title="0">if err := h.svc.AdminDeleteUser(c.Request.Context(), id); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}
</pre>

		<pre class="file" id="file9" style="display: none">package handler

import (
        "net/http"

        "github.com/gin-gonic/gin"

        "github.com/kusmin/gestao_updev/backend/internal/http/response"
        "github.com/kusmin/gestao_updev/backend/internal/service"
)

type SignupRequest struct {
        Company struct {
                Name     string `json:"name" binding:"required"`
                Document string `json:"document"`
                Phone    string `json:"phone"`
        } `json:"company" binding:"required"`
        User struct {
                Name     string `json:"name" binding:"required"`
                Email    string `json:"email" binding:"required,email"`
                Password string `json:"password" binding:"required,min=8"`
                Phone    string `json:"phone"`
        } `json:"user" binding:"required"`
}

type LoginRequest struct {
        Email    string `json:"email" binding:"required,email"`
        Password string `json:"password" binding:"required"`
}

type RefreshRequest struct {
        RefreshToken string `json:"refresh_token" binding:"required"`
}

// Signup
// @Summary Cria empresa e usuário administrador
// @Description Fluxo inicial da plataforma: cria empresa, usuário admin e retorna tokens.
// @Tags Auth
// @Accept json
// @Produce json
// @Param request body SignupRequest true "Dados do signup"
// @Success 201 {object} response.APIResponse
// @Failure 400 {object} response.APIResponse
// @Router /auth/signup [post]
func (api *API) Signup(c *gin.Context) <span class="cov0" title="0">{
        var req SignupRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "VALIDATION_ERROR", err.Error(), nil)
                return
        }</span>

        <span class="cov0" title="0">result, err := api.svc.Signup(c.Request.Context(), service.SignupInput{
                CompanyName:     req.Company.Name,
                CompanyDocument: req.Company.Document,
                CompanyPhone:    req.Company.Phone,
                UserName:        req.User.Name,
                UserEmail:       req.User.Email,
                UserPassword:    req.User.Password,
                UserPhone:       req.User.Phone,
        })
        if err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">response.Success(c, http.StatusCreated, gin.H{
                "tenant_id":     result.TenantID,
                "user_id":       result.UserID,
                "access_token":  result.Tokens.AccessToken,
                "refresh_token": result.Tokens.RefreshToken,
                "expires_in":    result.Tokens.ExpiresIn,
        }, nil)</span>
}

// Login
// @Summary Autentica usuário
// @Tags Auth
// @Accept json
// @Produce json
// @Param request body LoginRequest true "Credenciais"
// @Success 200 {object} response.APIResponse
// @Failure 400 {object} response.APIResponse
// @Failure 401 {object} response.APIResponse
// @Router /auth/login [post]
func (api *API) Login(c *gin.Context) <span class="cov0" title="0">{
        var req LoginRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "VALIDATION_ERROR", err.Error(), nil)
                return
        }</span>

        <span class="cov0" title="0">_, tokens, err := api.svc.Login(c.Request.Context(), req.Email, req.Password)
        if err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">response.Success(c, http.StatusOK, tokens, nil)</span>
}

// RefreshToken
// @Summary Atualiza tokens de acesso
// @Tags Auth
// @Accept json
// @Produce json
// @Param request body RefreshRequest true "Refresh token"
// @Success 200 {object} response.APIResponse
// @Failure 400 {object} response.APIResponse
// @Failure 401 {object} response.APIResponse
// @Router /auth/refresh [post]
func (api *API) RefreshToken(c *gin.Context) <span class="cov0" title="0">{
        var req RefreshRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "VALIDATION_ERROR", err.Error(), nil)
                return
        }</span>

        <span class="cov0" title="0">tokens, err := api.svc.RefreshTokens(c.Request.Context(), req.RefreshToken)
        if err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">response.Success(c, http.StatusOK, tokens, nil)</span>
}
</pre>

		<pre class="file" id="file10" style="display: none">package handler

import (
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"

        "github.com/kusmin/gestao_updev/backend/internal/http/response"
        "github.com/kusmin/gestao_updev/backend/internal/service"
)

type BookingRequest struct {
        ClientID       uuid.UUID  `json:"client_id" binding:"required"`
        ProfessionalID uuid.UUID  `json:"professional_id" binding:"required"`
        ServiceID      uuid.UUID  `json:"service_id" binding:"required"`
        Status         string     `json:"status"`
        StartAt        time.Time  `json:"start_at" binding:"required"`
        EndAt          *time.Time `json:"end_at"`
        Notes          string     `json:"notes"`
}

type BookingUpdateRequest struct {
        Status  *string    `json:"status"`
        StartAt *time.Time `json:"start_at"`
        EndAt   *time.Time `json:"end_at"`
        Notes   *string    `json:"notes"`
}

type BookingCancelRequest struct {
        Reason string `json:"reason"`
}

// ListBookings
// @Summary Lista agendamentos
// @Tags Bookings
// @Produce json
// @Security BearerAuth
// @Security TenantHeader
// @Param date query string false "Data (YYYY-MM-DD)"
// @Param professional_id query string false "Profissional"
// @Param status query string false "Status"
// @Success 200 {object} response.APIResponse
// @Router /bookings [get]
func (api *API) ListBookings(c *gin.Context) <span class="cov0" title="0">{
        tenantID, ok := api.tenantID(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">var (
                datePtr *time.Time
                profID  *uuid.UUID
        )
        if raw := c.Query("date"); raw != "" </span><span class="cov0" title="0">{
                if t, err := time.Parse("2006-01-02", raw); err == nil </span><span class="cov0" title="0">{
                        datePtr = &amp;t
                }</span>
        }
        <span class="cov0" title="0">if raw := c.Query("professional_id"); raw != "" </span><span class="cov0" title="0">{
                if id, err := uuid.Parse(raw); err == nil </span><span class="cov0" title="0">{
                        profID = &amp;id
                }</span>
        }

        <span class="cov0" title="0">bookings, err := api.svc.ListBookings(c.Request.Context(), tenantID, service.BookingFilter{
                Date:           datePtr,
                ProfessionalID: profID,
                Status:         c.Query("status"),
        })
        if err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>
        <span class="cov0" title="0">response.Success(c, http.StatusOK, bookings, nil)</span>
}

// CreateBooking
// @Summary Cria agendamento
// @Tags Bookings
// @Accept json
// @Produce json
// @Security BearerAuth
// @Security TenantHeader
// @Param request body BookingRequest true "Agendamento"
// @Success 201 {object} response.APIResponse
// @Router /bookings [post]
func (api *API) CreateBooking(c *gin.Context) <span class="cov0" title="0">{
        tenantID, ok := api.tenantID(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">var req BookingRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "VALIDATION_ERROR", err.Error(), nil)
                return
        }</span>

        <span class="cov0" title="0">booking, err := api.svc.CreateBooking(c.Request.Context(), tenantID, service.BookingInput{
                ClientID:       req.ClientID,
                ProfessionalID: req.ProfessionalID,
                ServiceID:      req.ServiceID,
                Status:         req.Status,
                StartAt:        req.StartAt,
                EndAt:          req.EndAt,
                Notes:          req.Notes,
        })
        if err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>
        <span class="cov0" title="0">response.Success(c, http.StatusCreated, booking, nil)</span>
}

// UpdateBooking
// @Summary Atualiza agendamento
// @Tags Bookings
// @Accept json
// @Produce json
// @Security BearerAuth
// @Security TenantHeader
// @Param id path string true "Booking ID"
// @Param request body BookingUpdateRequest true "Campos editáveis"
// @Success 200 {object} response.APIResponse
// @Router /bookings/{id} [patch]
func (api *API) UpdateBooking(c *gin.Context) <span class="cov0" title="0">{
        tenantID, ok := api.tenantID(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">bookingID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "INVALID_ID", "ID inválido", nil)
                return
        }</span>

        <span class="cov0" title="0">var req BookingUpdateRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "VALIDATION_ERROR", err.Error(), nil)
                return
        }</span>

        <span class="cov0" title="0">booking, err := api.svc.UpdateBooking(c.Request.Context(), tenantID, bookingID, service.BookingUpdateInput{
                Status:  req.Status,
                StartAt: req.StartAt,
                EndAt:   req.EndAt,
                Notes:   req.Notes,
        })
        if err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>
        <span class="cov0" title="0">response.Success(c, http.StatusOK, booking, nil)</span>
}

// CancelBooking
// @Summary Cancela agendamento
// @Tags Bookings
// @Accept json
// @Produce json
// @Security BearerAuth
// @Security TenantHeader
// @Param id path string true "Booking ID"
// @Param request body BookingCancelRequest true "Motivo"
// @Success 200 {object} response.APIResponse
// @Router /bookings/{id}/cancel [post]
func (api *API) CancelBooking(c *gin.Context) <span class="cov0" title="0">{
        tenantID, ok := api.tenantID(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">bookingID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "INVALID_ID", "ID inválido", nil)
                return
        }</span>

        <span class="cov0" title="0">var req BookingCancelRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "VALIDATION_ERROR", err.Error(), nil)
                return
        }</span>

        <span class="cov0" title="0">booking, err := api.svc.CancelBooking(c.Request.Context(), tenantID, bookingID, req.Reason)
        if err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>
        <span class="cov0" title="0">response.Success(c, http.StatusOK, booking, nil)</span>
}
</pre>

		<pre class="file" id="file11" style="display: none">package handler

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"

        "github.com/kusmin/gestao_updev/backend/internal/http/response"
        "github.com/kusmin/gestao_updev/backend/internal/service"
)

type ServiceRequest struct {
        Name            string                 `json:"name" binding:"required"`
        Category        string                 `json:"category"`
        Description     string                 `json:"description"`
        DurationMinutes int                    `json:"duration_minutes" binding:"required"`
        Price           float64                `json:"price" binding:"required"`
        Color           string                 `json:"color"`
        Metadata        map[string]interface{} `json:"metadata"`
}

type ProductRequest struct {
        Name        string                 `json:"name" binding:"required"`
        SKU         string                 `json:"sku" binding:"required"`
        Price       float64                `json:"price" binding:"required"`
        Cost        float64                `json:"cost"`
        StockQty    int                    `json:"stock_qty"`
        MinStock    int                    `json:"min_stock"`
        Description string                 `json:"description"`
        Metadata    map[string]interface{} `json:"metadata"`
}

// ListServices
// @Summary Lista serviços
// @Tags Services
// @Produce json
// @Security BearerAuth
// @Security TenantHeader
// @Success 200 {object} response.APIResponse
// @Router /services [get]
func (api *API) ListServices(c *gin.Context) <span class="cov0" title="0">{
        tenantID, ok := api.tenantID(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">servicesList, err := api.svc.ListServices(c.Request.Context(), tenantID)
        if err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>
        <span class="cov0" title="0">response.Success(c, http.StatusOK, servicesList, nil)</span>
}

// CreateService
// @Summary Cria serviço
// @Tags Services
// @Accept json
// @Produce json
// @Security BearerAuth
// @Security TenantHeader
// @Param request body ServiceRequest true "Serviço"
// @Success 201 {object} response.APIResponse
// @Router /services [post]
func (api *API) CreateService(c *gin.Context) <span class="cov0" title="0">{
        tenantID, ok := api.tenantID(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">var req ServiceRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "VALIDATION_ERROR", err.Error(), nil)
                return
        }</span>

        <span class="cov0" title="0">serviceObj, err := api.svc.CreateService(c.Request.Context(), tenantID, service.ServiceInput{
                Name:            req.Name,
                Category:        req.Category,
                Description:     req.Description,
                DurationMinutes: req.DurationMinutes,
                Price:           req.Price,
                Color:           req.Color,
                Metadata:        req.Metadata,
        })
        if err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">response.Success(c, http.StatusCreated, serviceObj, nil)</span>
}

// UpdateService
// @Summary Atualiza serviço
// @Tags Services
// @Accept json
// @Produce json
// @Security BearerAuth
// @Security TenantHeader
// @Param id path string true "Service ID"
// @Param request body ServiceRequest true "Serviço"
// @Success 200 {object} response.APIResponse
// @Router /services/{id} [put]
func (api *API) UpdateService(c *gin.Context) <span class="cov0" title="0">{
        tenantID, ok := api.tenantID(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">serviceID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "INVALID_ID", "ID inválido", nil)
                return
        }</span>

        <span class="cov0" title="0">var req ServiceRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "VALIDATION_ERROR", err.Error(), nil)
                return
        }</span>

        <span class="cov0" title="0">serviceObj, err := api.svc.UpdateService(c.Request.Context(), tenantID, serviceID, service.ServiceInput{
                Name:            req.Name,
                Category:        req.Category,
                Description:     req.Description,
                DurationMinutes: req.DurationMinutes,
                Price:           req.Price,
                Color:           req.Color,
                Metadata:        req.Metadata,
        })
        if err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">response.Success(c, http.StatusOK, serviceObj, nil)</span>
}

// DeleteService
// @Summary Remove serviço
// @Tags Services
// @Security BearerAuth
// @Security TenantHeader
// @Param id path string true "Service ID"
// @Success 204 "No Content"
// @Router /services/{id} [delete]
func (api *API) DeleteService(c *gin.Context) <span class="cov0" title="0">{
        tenantID, ok := api.tenantID(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">serviceID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "INVALID_ID", "ID inválido", nil)
                return
        }</span>

        <span class="cov0" title="0">if err := api.svc.DeleteService(c.Request.Context(), tenantID, serviceID); err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>
        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

// GetService
// @Summary Busca serviço por ID
// @Tags Services
// @Produce json
// @Security BearerAuth
// @Security TenantHeader
// @Param id path string true "Service ID"
// @Success 200 {object} response.APIResponse
// @Router /services/{id} [get]
func (api *API) GetService(c *gin.Context) <span class="cov0" title="0">{
        tenantID, ok := api.tenantID(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">serviceID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "INVALID_ID", "ID de serviço inválido", nil)
                return
        }</span>

        <span class="cov0" title="0">service, err := api.svc.GetService(c.Request.Context(), tenantID, serviceID)
        if err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">response.Success(c, http.StatusOK, service, nil)</span>
}

// ListProducts
// @Summary Lista produtos
// @Tags Products
// @Produce json
// @Security BearerAuth
// @Security TenantHeader
// @Success 200 {object} response.APIResponse
// @Router /products [get]
func (api *API) ListProducts(c *gin.Context) <span class="cov0" title="0">{
        tenantID, ok := api.tenantID(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">products, err := api.svc.ListProducts(c.Request.Context(), tenantID)
        if err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>
        <span class="cov0" title="0">response.Success(c, http.StatusOK, products, nil)</span>
}

// CreateProduct
// @Summary Cria produto
// @Tags Products
// @Accept json
// @Produce json
// @Security BearerAuth
// @Security TenantHeader
// @Param request body ProductRequest true "Produto"
// @Success 201 {object} response.APIResponse
// @Router /products [post]
func (api *API) CreateProduct(c *gin.Context) <span class="cov0" title="0">{
        tenantID, ok := api.tenantID(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">var req ProductRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "VALIDATION_ERROR", err.Error(), nil)
                return
        }</span>

        <span class="cov0" title="0">product, err := api.svc.CreateProduct(c.Request.Context(), tenantID, service.ProductInput{
                Name:        req.Name,
                SKU:         req.SKU,
                Price:       req.Price,
                Cost:        req.Cost,
                StockQty:    req.StockQty,
                MinStock:    req.MinStock,
                Description: req.Description,
                Metadata:    req.Metadata,
        })
        if err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">response.Success(c, http.StatusCreated, product, nil)</span>
}

// UpdateProduct
// @Summary Atualiza produto
// @Tags Products
// @Accept json
// @Produce json
// @Security BearerAuth
// @Security TenantHeader
// @Param id path string true "Product ID"
// @Param request body ProductRequest true "Produto"
// @Success 200 {object} response.APIResponse
// @Router /products/{id} [put]
func (api *API) UpdateProduct(c *gin.Context) <span class="cov0" title="0">{
        tenantID, ok := api.tenantID(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">productID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "INVALID_ID", "ID inválido", nil)
                return
        }</span>

        <span class="cov0" title="0">var req ProductRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "VALIDATION_ERROR", err.Error(), nil)
                return
        }</span>

        <span class="cov0" title="0">product, err := api.svc.UpdateProduct(c.Request.Context(), tenantID, productID, service.ProductInput{
                Name:        req.Name,
                SKU:         req.SKU,
                Price:       req.Price,
                Cost:        req.Cost,
                StockQty:    req.StockQty,
                MinStock:    req.MinStock,
                Description: req.Description,
                Metadata:    req.Metadata,
        })
        if err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>
        <span class="cov0" title="0">response.Success(c, http.StatusOK, product, nil)</span>
}

// DeleteProduct
// @Summary Remove produto
// @Tags Products
// @Security BearerAuth
// @Security TenantHeader
// @Param id path string true "Product ID"
// @Success 204 "No Content"
// @Router /products/{id} [delete]
func (api *API) DeleteProduct(c *gin.Context) <span class="cov0" title="0">{
        tenantID, ok := api.tenantID(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">productID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "INVALID_ID", "ID inválido", nil)
                return
        }</span>

        <span class="cov0" title="0">if err := api.svc.DeleteProduct(c.Request.Context(), tenantID, productID); err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>
        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

// GetProduct
// @Summary Busca produto por ID
// @Tags Products
// @Produce json
// @Security BearerAuth
// @Security TenantHeader
// @Param id path string true "Product ID"
// @Success 200 {object} response.APIResponse
// @Router /products/{id} [get]
func (api *API) GetProduct(c *gin.Context) <span class="cov0" title="0">{
        tenantID, ok := api.tenantID(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">productID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "INVALID_ID", "ID de produto inválido", nil)
                return
        }</span>

        <span class="cov0" title="0">product, err := api.svc.GetProduct(c.Request.Context(), tenantID, productID)
        if err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">response.Success(c, http.StatusOK, product, nil)</span>
}
</pre>

		<pre class="file" id="file12" style="display: none">package handler

import (
        "net/http"
        "strconv"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"

        "github.com/kusmin/gestao_updev/backend/internal/http/response"
        "github.com/kusmin/gestao_updev/backend/internal/service"
)

type ClientRequest struct {
        Name    string                 `json:"name" binding:"required"`
        Email   string                 `json:"email"`
        Phone   string                 `json:"phone"`
        Notes   string                 `json:"notes"`
        Tags    []string               `json:"tags"`
        Contact map[string]interface{} `json:"contact"`
}

// ListClients
// @Summary Lista clientes
// @Tags Clients
// @Produce json
// @Security BearerAuth
// @Security TenantHeader
// @Param search query string false "Filtro por nome/email/telefone"
// @Param tags query string false "Lista de tags separadas por vírgula"
// @Param page query int false "Página" default(1)
// @Param per_page query int false "Itens por página" default(20)
// @Success 200 {object} response.APIResponse
// @Router /clients [get]
func (api *API) ListClients(c *gin.Context) <span class="cov0" title="0">{
        tenantID, ok := api.tenantID(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        perPage, _ := strconv.Atoi(c.DefaultQuery("per_page", "20"))
        search := c.Query("search")
        var tags []string
        if raw := c.Query("tags"); raw != "" </span><span class="cov0" title="0">{
                for _, tag := range strings.Split(raw, ",") </span><span class="cov0" title="0">{
                        tag = strings.TrimSpace(tag)
                        if tag != "" </span><span class="cov0" title="0">{
                                tags = append(tags, tag)
                        }</span>
                }
        }

        <span class="cov0" title="0">clients, total, err := api.svc.ListClients(c.Request.Context(), tenantID, service.ClientsFilter{
                Search:  search,
                Tags:    tags,
                Page:    page,
                PerPage: perPage,
        })
        if err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">response.Success(c, http.StatusOK, clients, metaPagination(page, perPage, total))</span>
}

// CreateClient
// @Summary Cria cliente
// @Tags Clients
// @Accept json
// @Produce json
// @Security BearerAuth
// @Security TenantHeader
// @Param request body ClientRequest true "Cliente"
// @Success 201 {object} response.APIResponse
// @Failure 400 {object} response.APIResponse
// @Router /clients [post]
func (api *API) CreateClient(c *gin.Context) <span class="cov0" title="0">{
        tenantID, ok := api.tenantID(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">var req ClientRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "VALIDATION_ERROR", err.Error(), nil)
                return
        }</span>

        <span class="cov0" title="0">client, err := api.svc.CreateClient(c.Request.Context(), tenantID, service.ClientInput{
                Name:    req.Name,
                Email:   req.Email,
                Phone:   req.Phone,
                Notes:   req.Notes,
                Tags:    req.Tags,
                Contact: req.Contact,
        })
        if err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">response.Success(c, http.StatusCreated, client, nil)</span>
}

// GetClient
// @Summary Busca cliente
// @Tags Clients
// @Produce json
// @Security BearerAuth
// @Security TenantHeader
// @Param id path string true "Client ID"
// @Success 200 {object} response.APIResponse
// @Router /clients/{id} [get]
func (api *API) GetClient(c *gin.Context) <span class="cov0" title="0">{
        tenantID, ok := api.tenantID(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">clientID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "INVALID_ID", "ID inválido", nil)
                return
        }</span>

        <span class="cov0" title="0">client, stats, err := api.svc.GetClient(c.Request.Context(), tenantID, clientID)
        if err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">data := gin.H{"client": client}
        if stats != nil </span><span class="cov0" title="0">{
                data["stats"] = stats
        }</span>
        <span class="cov0" title="0">response.Success(c, http.StatusOK, data, nil)</span>
}

// UpdateClient
// @Summary Atualiza cliente
// @Tags Clients
// @Accept json
// @Produce json
// @Security BearerAuth
// @Security TenantHeader
// @Param id path string true "Client ID"
// @Param request body ClientRequest true "Cliente"
// @Success 200 {object} response.APIResponse
// @Router /clients/{id} [put]
func (api *API) UpdateClient(c *gin.Context) <span class="cov0" title="0">{
        tenantID, ok := api.tenantID(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">clientID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "INVALID_ID", "ID inválido", nil)
                return
        }</span>

        <span class="cov0" title="0">var req ClientRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "VALIDATION_ERROR", err.Error(), nil)
                return
        }</span>

        <span class="cov0" title="0">client, err := api.svc.UpdateClient(c.Request.Context(), tenantID, clientID, service.ClientInput{
                Name:    req.Name,
                Email:   req.Email,
                Phone:   req.Phone,
                Notes:   req.Notes,
                Tags:    req.Tags,
                Contact: req.Contact,
        })
        if err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">response.Success(c, http.StatusOK, client, nil)</span>
}

// DeleteClient
// @Summary Remove cliente
// @Tags Clients
// @Security BearerAuth
// @Security TenantHeader
// @Param id path string true "Client ID"
// @Success 204 "No Content"
// @Router /clients/{id} [delete]
func (api *API) DeleteClient(c *gin.Context) <span class="cov0" title="0">{
        tenantID, ok := api.tenantID(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">clientID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "INVALID_ID", "ID inválido", nil)
                return
        }</span>

        <span class="cov0" title="0">if err := api.svc.DeleteClient(c.Request.Context(), tenantID, clientID); err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>
        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}
</pre>

		<pre class="file" id="file13" style="display: none">package handler

import (
        "net/http"

        "github.com/gin-gonic/gin"

        "github.com/kusmin/gestao_updev/backend/internal/http/response"
        "github.com/kusmin/gestao_updev/backend/internal/service"
)

type CompanyUpdateRequest struct {
        Name     *string                `json:"name"`
        Timezone *string                `json:"timezone"`
        Phone    *string                `json:"phone"`
        Email    *string                `json:"email"`
        Settings map[string]interface{} `json:"settings"`
}

// GetCompany
// @Summary Retorna dados da empresa atual
// @Tags Company
// @Produce json
// @Security BearerAuth
// @Security TenantHeader
// @Success 200 {object} response.APIResponse
// @Failure 401 {object} response.APIResponse
// @Router /companies/me [get]
func (api *API) GetCompany(c *gin.Context) <span class="cov0" title="0">{
        tenantID, ok := api.tenantID(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">company, err := api.svc.GetCompany(c.Request.Context(), tenantID)
        if err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>
        <span class="cov0" title="0">response.Success(c, http.StatusOK, company, nil)</span>
}

// UpdateCompany
// @Summary Atualiza dados da empresa atual
// @Tags Company
// @Accept json
// @Produce json
// @Security BearerAuth
// @Security TenantHeader
// @Param request body CompanyUpdateRequest true "Campos editáveis"
// @Success 200 {object} response.APIResponse
// @Failure 400 {object} response.APIResponse
// @Router /companies/me [put]
func (api *API) UpdateCompany(c *gin.Context) <span class="cov0" title="0">{
        tenantID, ok := api.tenantID(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">var req CompanyUpdateRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "VALIDATION_ERROR", err.Error(), nil)
                return
        }</span>

        <span class="cov0" title="0">company, err := api.svc.UpdateCompany(c.Request.Context(), tenantID, service.CompanyUpdateInput{
                Name:     req.Name,
                Timezone: req.Timezone,
                Phone:    req.Phone,
                Email:    req.Email,
                Settings: req.Settings,
        })
        if err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>
        <span class="cov0" title="0">response.Success(c, http.StatusOK, company, nil)</span>
}
</pre>

		<pre class="file" id="file14" style="display: none">package handler

import (
        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/kusmin/gestao_updev/backend/internal/service"
        "net/http"
)

type CompanyHandler struct {
        service *service.CompanyService
}

func NewCompanyHandler(service *service.CompanyService) *CompanyHandler <span class="cov10" title="2">{
        return &amp;CompanyHandler{service: service}
}</span>

func (h *CompanyHandler) RegisterRoutes(router *gin.RouterGroup) <span class="cov10" title="2">{
        router.GET("/tenants", h.ListAllCompanies)
        router.GET("/tenants/:id", h.GetCompanyByID)
        router.POST("/tenants", h.CreateCompany)
        router.PUT("/tenants/:id", h.UpdateCompany)
        router.DELETE("/tenants/:id", h.DeleteCompany)
}</span>

func (h *CompanyHandler) ListAllCompanies(c *gin.Context) <span class="cov0" title="0">{
        companies, err := h.service.ListAllCompanies(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"data": companies})</span>
}

func (h *CompanyHandler) GetCompanyByID(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid id"})
                return
        }</span>

        <span class="cov0" title="0">company, err := h.service.GetCompanyByID(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "company not found"})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"data": company})</span>
}

func (h *CompanyHandler) CreateCompany(c *gin.Context) <span class="cov0" title="0">{
        var input service.CreateCompanyInput
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">company, err := h.service.CreateCompany(c.Request.Context(), input)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{"data": company})</span>
}

func (h *CompanyHandler) UpdateCompany(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid id"})
                return
        }</span>

        <span class="cov0" title="0">var input service.UpdateCompanyInput
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">company, err := h.service.UpdateCompany(c.Request.Context(), id, input)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"data": company})</span>
}

func (h *CompanyHandler) DeleteCompany(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid id"})
                return
        }</span>

        <span class="cov0" title="0">if err := h.service.DeleteCompany(c.Request.Context(), id); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}
</pre>

		<pre class="file" id="file15" style="display: none">package handler

import (
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"

        "github.com/kusmin/gestao_updev/backend/internal/http/response"
)

// DashboardDaily
// @Summary KPIs diários
// @Tags Dashboard
// @Produce json
// @Security BearerAuth
// @Security TenantHeader
// @Param date query string false "Data (YYYY-MM-DD)"
// @Param professional_id query string false "Profissional"
// @Success 200 {object} response.APIResponse
// @Router /dashboard/daily [get]
func (api *API) DashboardDaily(c *gin.Context) <span class="cov0" title="0">{
        tenantID, ok := api.tenantID(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">date := time.Now()
        if raw := c.Query("date"); raw != "" </span><span class="cov0" title="0">{
                if d, err := time.Parse("2006-01-02", raw); err == nil </span><span class="cov0" title="0">{
                        date = d
                }</span>
        }

        <span class="cov0" title="0">var professionalID *uuid.UUID
        if raw := c.Query("professional_id"); raw != "" </span><span class="cov0" title="0">{
                if id, err := uuid.Parse(raw); err == nil </span><span class="cov0" title="0">{
                        professionalID = &amp;id
                }</span>
        }

        <span class="cov0" title="0">result, err := api.svc.DashboardDaily(c.Request.Context(), tenantID, date, professionalID)
        if err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>
        <span class="cov0" title="0">response.Success(c, http.StatusOK, result, nil)</span>
}
</pre>

		<pre class="file" id="file16" style="display: none">package handler

import (
        "errors"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.uber.org/zap"

        "github.com/kusmin/gestao_updev/backend/internal/http/contextutil"
        "github.com/kusmin/gestao_updev/backend/internal/http/response"
        "github.com/kusmin/gestao_updev/backend/internal/service"
)

// API agrega os handlers HTTP.
type API struct {
        svc    *service.Service
        logger *zap.Logger
}

// New cria um handler básico.
func New(svc *service.Service, logger *zap.Logger) *API <span class="cov8" title="6">{
        return &amp;API{
                svc:    svc,
                logger: logger,
        }
}</span>

func (api *API) tenantID(c *gin.Context) (uuid.UUID, bool) <span class="cov10" title="8">{
        tenantID, err := contextutil.TenantID(c)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "TENANT_ID_REQUIRED", "Tenant inválido", nil)
                return uuid.Nil, false
        }</span>
        <span class="cov10" title="8">return tenantID, true</span>
}

func (api *API) parseUUIDParam(c *gin.Context, key string) (uuid.UUID, bool) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param(key))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "INVALID_ID", "Identificador inválido", nil)
                return uuid.Nil, false
        }</span>
        <span class="cov0" title="0">return id, true</span>
}

func (api *API) handleError(c *gin.Context, err error) <span class="cov4" title="2">{
        if errors.Is(err, service.ErrInvalidCredentials) </span><span class="cov0" title="0">{
                response.Error(c, http.StatusUnauthorized, "INVALID_CREDENTIALS", "Credenciais inválidas", nil)
                return
        }</span>
        <span class="cov4" title="2">if errors.Is(err, service.ErrBookingConflict) </span><span class="cov0" title="0">{
                response.Error(c, http.StatusConflict, "BOOKING_CONFLICT", err.Error(), nil)
                return
        }</span>
        <span class="cov4" title="2">response.Error(c, http.StatusInternalServerError, "INTERNAL_ERROR", err.Error(), nil)</span>
}

func metaPagination(page, perPage int, total int64) gin.H <span class="cov0" title="0">{
        return gin.H{
                "pagination": gin.H{
                        "page":     page,
                        "per_page": perPage,
                        "total":    total,
                },
        }
}</span>
</pre>

		<pre class="file" id="file17" style="display: none">package handler

import (
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"

        "github.com/kusmin/gestao_updev/backend/internal/http/response"
        "github.com/kusmin/gestao_updev/backend/internal/service"
)

type InventoryRequest struct {
        ProductID uuid.UUID  `json:"product_id" binding:"required"`
        OrderID   *uuid.UUID `json:"order_id"`
        Type      string     `json:"type" binding:"required"`
        Quantity  int        `json:"quantity" binding:"required"`
        Reason    string     `json:"reason"`
}

// ListInventoryMovements
// @Summary Lista movimentações de estoque
// @Tags Inventory
// @Produce json
// @Security BearerAuth
// @Security TenantHeader
// @Param product_id query string false "Filtro por produto"
// @Param type query string false "Tipo (in|out|adjustment)"
// @Param start_date query string false "Data inicial (RFC3339)"
// @Param end_date query string false "Data final (RFC3339)"
// @Success 200 {object} response.APIResponse
// @Router /inventory/movements [get]
func (api *API) ListInventoryMovements(c *gin.Context) <span class="cov0" title="0">{
        tenantID, ok := api.tenantID(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">var (
                productID *uuid.UUID
                startDate *time.Time
                endDate   *time.Time
        )

        if raw := c.Query("product_id"); raw != "" </span><span class="cov0" title="0">{
                id, err := uuid.Parse(raw)
                if err == nil </span><span class="cov0" title="0">{
                        productID = &amp;id
                }</span>
        }
        <span class="cov0" title="0">if raw := c.Query("start_date"); raw != "" </span><span class="cov0" title="0">{
                if t, err := time.Parse(time.RFC3339, raw); err == nil </span><span class="cov0" title="0">{
                        startDate = &amp;t
                }</span>
        }
        <span class="cov0" title="0">if raw := c.Query("end_date"); raw != "" </span><span class="cov0" title="0">{
                if t, err := time.Parse(time.RFC3339, raw); err == nil </span><span class="cov0" title="0">{
                        endDate = &amp;t
                }</span>
        }
        <span class="cov0" title="0">movements, err := api.svc.ListInventoryMovements(c.Request.Context(), tenantID, service.InventoryFilter{
                ProductID: productID,
                Type:      c.Query("type"),
                StartDate: startDate,
                EndDate:   endDate,
        })
        if err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>
        <span class="cov0" title="0">response.Success(c, http.StatusOK, movements, nil)</span>
}

// CreateInventoryMovement
// @Summary Registra movimento de estoque
// @Tags Inventory
// @Accept json
// @Produce json
// @Security BearerAuth
// @Security TenantHeader
// @Param request body InventoryRequest true "Movimentação"
// @Success 201 {object} response.APIResponse
// @Router /inventory/movements [post]
func (api *API) CreateInventoryMovement(c *gin.Context) <span class="cov0" title="0">{
        tenantID, ok := api.tenantID(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">var req InventoryRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "VALIDATION_ERROR", err.Error(), nil)
                return
        }</span>

        <span class="cov0" title="0">movement, err := api.svc.CreateInventoryMovement(c.Request.Context(), tenantID, service.InventoryInput{
                ProductID: req.ProductID,
                OrderID:   req.OrderID,
                Type:      req.Type,
                Quantity:  req.Quantity,
                Reason:    req.Reason,
        })
        if err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>
        <span class="cov0" title="0">response.Success(c, http.StatusCreated, movement, nil)</span>
}
</pre>

		<pre class="file" id="file18" style="display: none">package handler

import (
        "net/http"

        "github.com/gin-gonic/gin"

        "github.com/kusmin/gestao_updev/backend/internal/http/response"
)

// ListProfessionals
// @Summary Lista profissionais ativos
// @Tags Professionals
// @Produce json
// @Security BearerAuth
// @Security TenantHeader
// @Success 200 {object} response.APIResponse
// @Router /professionals [get]
func (api *API) ListProfessionals(c *gin.Context) <span class="cov0" title="0">{
        tenantID, ok := api.tenantID(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">professionals, err := api.svc.ListProfessionals(c.Request.Context(), tenantID)
        if err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>
        <span class="cov0" title="0">response.Success(c, http.StatusOK, professionals, nil)</span>
}
</pre>

		<pre class="file" id="file19" style="display: none">package handler

import (
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"

        "github.com/kusmin/gestao_updev/backend/internal/http/response"
        "github.com/kusmin/gestao_updev/backend/internal/service"
)

type SalesOrderItemRequest struct {
        Type      string    `json:"type" binding:"required"`
        RefID     uuid.UUID `json:"ref_id" binding:"required"`
        Quantity  int       `json:"quantity" binding:"required"`
        UnitPrice float64   `json:"unit_price" binding:"required"`
}

type SalesOrderRequest struct {
        ClientID  uuid.UUID               `json:"client_id" binding:"required"`
        BookingID *uuid.UUID              `json:"booking_id"`
        Items     []SalesOrderItemRequest `json:"items" binding:"required,dive"`
        Discount  float64                 `json:"discount"`
        Notes     string                  `json:"notes"`
}

type SalesOrderUpdateRequest struct {
        Status *string `json:"status"`
        Notes  *string `json:"notes"`
}

type PaymentRequest struct {
        Method  string                 `json:"method" binding:"required"`
        Amount  float64                `json:"amount" binding:"required"`
        PaidAt  time.Time              `json:"paid_at" binding:"required"`
        Details map[string]interface{} `json:"details"`
}

// ListSalesOrders
// @Summary Lista pedidos/vendas
// @Tags Sales
// @Produce json
// @Security BearerAuth
// @Security TenantHeader
// @Param status query string false "Status"
// @Param client_id query string false "Cliente"
// @Param date query string false "Data (YYYY-MM-DD)"
// @Success 200 {object} response.APIResponse
// @Router /sales/orders [get]
func (api *API) ListSalesOrders(c *gin.Context) <span class="cov0" title="0">{
        tenantID, ok := api.tenantID(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">var (
                clientID *uuid.UUID
                datePtr  *time.Time
        )
        if raw := c.Query("client_id"); raw != "" </span><span class="cov0" title="0">{
                if id, err := uuid.Parse(raw); err == nil </span><span class="cov0" title="0">{
                        clientID = &amp;id
                }</span>
        }
        <span class="cov0" title="0">if raw := c.Query("date"); raw != "" </span><span class="cov0" title="0">{
                if d, err := time.Parse("2006-01-02", raw); err == nil </span><span class="cov0" title="0">{
                        datePtr = &amp;d
                }</span>
        }

        <span class="cov0" title="0">orders, err := api.svc.ListSalesOrders(c.Request.Context(), tenantID, service.SalesOrderFilter{
                Status:   c.Query("status"),
                ClientID: clientID,
                Date:     datePtr,
        })
        if err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>
        <span class="cov0" title="0">response.Success(c, http.StatusOK, orders, nil)</span>
}

// CreateSalesOrder
// @Summary Cria pedido/venda
// @Tags Sales
// @Accept json
// @Produce json
// @Security BearerAuth
// @Security TenantHeader
// @Param request body SalesOrderRequest true "Pedido"
// @Success 201 {object} response.APIResponse
// @Router /sales/orders [post]
func (api *API) CreateSalesOrder(c *gin.Context) <span class="cov0" title="0">{
        tenantID, ok := api.tenantID(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">var req SalesOrderRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "VALIDATION_ERROR", err.Error(), nil)
                return
        }</span>

        <span class="cov0" title="0">items := make([]service.SalesItemInput, len(req.Items))
        for i, item := range req.Items </span><span class="cov0" title="0">{
                items[i] = service.SalesItemInput{
                        Type:      item.Type,
                        RefID:     item.RefID,
                        Quantity:  item.Quantity,
                        UnitPrice: item.UnitPrice,
                }
        }</span>

        <span class="cov0" title="0">order, err := api.svc.CreateSalesOrder(c.Request.Context(), tenantID, service.SalesOrderInput{
                ClientID:  req.ClientID,
                BookingID: req.BookingID,
                Items:     items,
                Discount:  req.Discount,
                Notes:     req.Notes,
        })
        if err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>
        <span class="cov0" title="0">response.Success(c, http.StatusCreated, order, nil)</span>
}

// UpdateSalesOrder
// @Summary Atualiza pedido
// @Tags Sales
// @Accept json
// @Produce json
// @Security BearerAuth
// @Security TenantHeader
// @Param id path string true "Order ID"
// @Param request body SalesOrderUpdateRequest true "Campos editáveis"
// @Success 200 {object} response.APIResponse
// @Router /sales/orders/{id} [patch]
func (api *API) UpdateSalesOrder(c *gin.Context) <span class="cov0" title="0">{
        tenantID, ok := api.tenantID(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">orderID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "INVALID_ID", "ID inválido", nil)
                return
        }</span>

        <span class="cov0" title="0">var req SalesOrderUpdateRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "VALIDATION_ERROR", err.Error(), nil)
                return
        }</span>

        <span class="cov0" title="0">order, err := api.svc.UpdateSalesOrder(c.Request.Context(), tenantID, orderID, service.SalesOrderUpdateInput{
                Status: req.Status,
                Notes:  req.Notes,
        })
        if err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>
        <span class="cov0" title="0">response.Success(c, http.StatusOK, order, nil)</span>
}

// CreatePayment
// @Summary Registra pagamento
// @Tags Payments
// @Accept json
// @Produce json
// @Security BearerAuth
// @Security TenantHeader
// @Param id path string true "Order ID"
// @Param request body PaymentRequest true "Pagamento"
// @Success 201 {object} response.APIResponse
// @Router /sales/orders/{id}/payments [post]
func (api *API) CreatePayment(c *gin.Context) <span class="cov0" title="0">{
        tenantID, ok := api.tenantID(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">orderID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "INVALID_ID", "ID inválido", nil)
                return
        }</span>

        <span class="cov0" title="0">var req PaymentRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "VALIDATION_ERROR", err.Error(), nil)
                return
        }</span>

        <span class="cov0" title="0">payment, err := api.svc.AddPayment(c.Request.Context(), tenantID, orderID, service.PaymentInput{
                Method:  req.Method,
                Amount:  req.Amount,
                PaidAt:  req.PaidAt,
                Details: req.Details,
        })
        if err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>
        <span class="cov0" title="0">response.Success(c, http.StatusCreated, payment, nil)</span>
}

// ListPayments
// @Summary Lista pagamentos
// @Tags Payments
// @Produce json
// @Security BearerAuth
// @Security TenantHeader
// @Param method query string false "Método"
// @Param start_date query string false "Data inicial RFC3339"
// @Param end_date query string false "Data final RFC3339"
// @Success 200 {object} response.APIResponse
// @Router /payments [get]
func (api *API) ListPayments(c *gin.Context) <span class="cov0" title="0">{
        tenantID, ok := api.tenantID(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">var (
                startDate *time.Time
                endDate   *time.Time
        )
        if raw := c.Query("start_date"); raw != "" </span><span class="cov0" title="0">{
                if t, err := time.Parse(time.RFC3339, raw); err == nil </span><span class="cov0" title="0">{
                        startDate = &amp;t
                }</span>
        }
        <span class="cov0" title="0">if raw := c.Query("end_date"); raw != "" </span><span class="cov0" title="0">{
                if t, err := time.Parse(time.RFC3339, raw); err == nil </span><span class="cov0" title="0">{
                        endDate = &amp;t
                }</span>
        }

        <span class="cov0" title="0">payments, err := api.svc.ListPayments(c.Request.Context(), tenantID, service.PaymentFilter{
                Method:    c.Query("method"),
                StartDate: startDate,
                EndDate:   endDate,
        })
        if err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>
        <span class="cov0" title="0">response.Success(c, http.StatusOK, payments, nil)</span>
}
</pre>

		<pre class="file" id="file20" style="display: none">package handler

import (
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"

        "github.com/kusmin/gestao_updev/backend/internal/http/response"
        "github.com/kusmin/gestao_updev/backend/internal/service"
)

type CreateUserRequest struct {
        Name     string `json:"name" binding:"required"`
        Email    string `json:"email" binding:"required,email"`
        Password string `json:"password" binding:"required,min=8"`
        Phone    string `json:"phone"`
        Role     string `json:"role" binding:"required"`
}

type UpdateUserRequest struct {
        Name     *string `json:"name"`
        Phone    *string `json:"phone"`
        Role     *string `json:"role"`
        Active   *bool   `json:"active"`
        Password *string `json:"password"`
}

// ListUsers
// @Summary Lista usuários do tenant
// @Tags Users
// @Produce json
// @Security BearerAuth
// @Security TenantHeader
// @Param role query string false "Filtro por role"
// @Param page query int false "Página" default(1)
// @Param per_page query int false "Itens por página" default(20)
// @Success 200 {object} response.APIResponse
// @Router /users [get]
func (api *API) ListUsers(c *gin.Context) <span class="cov0" title="0">{
        tenantID, ok := api.tenantID(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        perPage, _ := strconv.Atoi(c.DefaultQuery("per_page", "20"))
        role := c.Query("role")

        users, total, err := api.svc.ListUsers(c.Request.Context(), tenantID, service.UsersFilter{
                Role:    role,
                Page:    page,
                PerPage: perPage,
        })
        if err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>

        <span class="cov0" title="0">response.Success(c, http.StatusOK, users, metaPagination(page, perPage, total))</span>
}

// GetUser
// @Summary Busca usuário por ID
// @Tags Users
// @Produce json
// @Security BearerAuth
// @Security TenantHeader
// @Param id path string true "User ID"
// @Success 200 {object} response.APIResponse
// @Router /users/{id} [get]
func (api *API) GetUser(c *gin.Context) <span class="cov5" title="2">{
        tenantID, ok := api.tenantID(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov5" title="2">userID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "INVALID_ID", "ID de usuário inválido", nil)
                return
        }</span>

        <span class="cov5" title="2">user, err := api.svc.GetUser(c.Request.Context(), tenantID, userID)
        if err != nil </span><span class="cov1" title="1">{
                api.handleError(c, err)
                return
        }</span>

        <span class="cov1" title="1">response.Success(c, http.StatusOK, user, nil)</span>
}

// CreateUser
// @Summary Cria um usuário
// @Tags Users
// @Accept json
// @Produce json
// @Security BearerAuth
// @Security TenantHeader
// @Param request body CreateUserRequest true "Novo usuário"
// @Success 201 {object} response.APIResponse
// @Failure 400 {object} response.APIResponse
// @Router /users [post]
func (api *API) CreateUser(c *gin.Context) <span class="cov10" title="4">{
        tenantID, ok := api.tenantID(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov10" title="4">var req CreateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                response.Error(c, http.StatusBadRequest, "VALIDATION_ERROR", err.Error(), nil)
                return
        }</span>

        <span class="cov8" title="3">user, err := api.svc.CreateUser(c.Request.Context(), tenantID, service.CreateUserInput{
                Name:     req.Name,
                Email:    req.Email,
                Password: req.Password,
                Phone:    req.Phone,
                Role:     req.Role,
        })
        if err != nil </span><span class="cov1" title="1">{
                api.handleError(c, err)
                return
        }</span>

        <span class="cov5" title="2">response.Success(c, http.StatusCreated, user, nil)</span>
}

// UpdateUser
// @Summary Atualiza parcialmente um usuário
// @Tags Users
// @Accept json
// @Produce json
// @Security BearerAuth
// @Security TenantHeader
// @Param id path string true "User ID"
// @Param request body UpdateUserRequest true "Campos editáveis"
// @Success 200 {object} response.APIResponse
// @Router /users/{id} [patch]
func (api *API) UpdateUser(c *gin.Context) <span class="cov1" title="1">{
        tenantID, ok := api.tenantID(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov1" title="1">userID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "INVALID_ID", "ID inválido", nil)
                return
        }</span>

        <span class="cov1" title="1">var req UpdateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "VALIDATION_ERROR", err.Error(), nil)
                return
        }</span>

        <span class="cov1" title="1">user, err := api.svc.UpdateUser(c.Request.Context(), tenantID, userID, service.UpdateUserInput{
                Name:     req.Name,
                Phone:    req.Phone,
                Role:     req.Role,
                Active:   req.Active,
                Password: req.Password,
        })
        if err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>

        <span class="cov1" title="1">response.Success(c, http.StatusOK, user, nil)</span>
}

// DeleteUser
// @Summary Remove (soft delete) um usuário
// @Tags Users
// @Security BearerAuth
// @Security TenantHeader
// @Param id path string true "User ID"
// @Success 204 "No Content"
// @Router /users/{id} [delete]
func (api *API) DeleteUser(c *gin.Context) <span class="cov1" title="1">{
        tenantID, ok := api.tenantID(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov1" title="1">userID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(c, http.StatusBadRequest, "INVALID_ID", "ID inválido", nil)
                return
        }</span>

        <span class="cov1" title="1">if err := api.svc.DeleteUser(c.Request.Context(), tenantID, userID); err != nil </span><span class="cov0" title="0">{
                api.handleError(c, err)
                return
        }</span>

        <span class="cov1" title="1">c.Status(http.StatusNoContent)</span>
}
</pre>

		<pre class="file" id="file21" style="display: none">package response

import "github.com/gin-gonic/gin"

// APIError representa erros padronizados.
type APIError struct {
        Code    string      `json:"code"`
        Message string      `json:"message"`
        Details interface{} `json:"details,omitempty"`
}

// APIResponse padroniza todas as respostas JSON.
type APIResponse struct {
        Data  interface{} `json:"data"`
        Meta  interface{} `json:"meta,omitempty"`
        Error interface{} `json:"error"`
}

// Success envia uma resposta com dados válidos.
func Success(c *gin.Context, status int, data interface{}, meta interface{}) <span class="cov10" title="6">{
        c.JSON(status, APIResponse{
                Data:  data,
                Meta:  meta,
                Error: nil,
        })
}</span>

// Error envia uma resposta consistente de erro.
func Error(c *gin.Context, status int, code, message string, details interface{}) <span class="cov10" title="6">{
        c.JSON(status, APIResponse{
                Data: nil,
                Error: APIError{
                        Code:    code,
                        Message: message,
                        Details: details,
                },
        })
}</span>
</pre>

		<pre class="file" id="file22" style="display: none">package middleware

import (
        "github.com/gin-gonic/gin"
        "github.com/kusmin/gestao_updev/backend/internal/auth"
        "github.com/kusmin/gestao_updev/backend/internal/http/response"
        "net/http"
)

func Admin() gin.HandlerFunc <span class="cov10" title="2">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                claims, exists := c.Get("claims")
                if !exists </span><span class="cov0" title="0">{
                        response.Error(c, http.StatusUnauthorized, "UNAUTHORIZED", "unauthorized", nil)
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">jwtClaims, ok := claims.(*auth.Claims)
                if !ok </span><span class="cov0" title="0">{
                        response.Error(c, http.StatusUnauthorized, "UNAUTHORIZED", "unauthorized", nil)
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">if jwtClaims.Role != "admin" </span><span class="cov0" title="0">{
                        response.Error(c, http.StatusForbidden, "FORBIDDEN", "forbidden", nil)
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>

		<pre class="file" id="file23" style="display: none">package middleware

import (
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"

        "github.com/kusmin/gestao_updev/backend/internal/auth"
        "github.com/kusmin/gestao_updev/backend/internal/http/response"
)

const (
        ContextUserIDKey   = "user_id"
        ContextUserRoleKey = "user_role"
        ContextTenantIDKey = "tenant_id"
)

// Auth valida o JWT e sincroniza tenant/token.
func Auth(jwtManager *auth.JWTManager, tenantHeader string) gin.HandlerFunc <span class="cov9" title="8">{
        return func(c *gin.Context) </span><span class="cov10" title="9">{
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov1" title="1">{
                        response.Error(c, http.StatusUnauthorized, "UNAUTHORIZED", "Token ausente", nil)
                        c.Abort()
                        return
                }</span>

                <span class="cov9" title="8">parts := strings.SplitN(authHeader, " ", 2)
                if len(parts) != 2 || !strings.EqualFold(parts[0], "Bearer") </span><span class="cov0" title="0">{
                        response.Error(c, http.StatusUnauthorized, "UNAUTHORIZED", "Cabeçalho Authorization inválido", nil)
                        c.Abort()
                        return
                }</span>

                <span class="cov9" title="8">claims, err := jwtManager.ValidateAccessToken(parts[1])
                if err != nil </span><span class="cov0" title="0">{
                        response.Error(c, http.StatusUnauthorized, "UNAUTHORIZED", "Token inválido ou expirado", nil)
                        c.Abort()
                        return
                }</span>

                <span class="cov9" title="8">headerTenant := c.GetHeader(tenantHeader)
                if headerTenant != "" &amp;&amp; !strings.EqualFold(headerTenant, claims.TenantID) </span><span class="cov0" title="0">{
                        response.Error(c, http.StatusForbidden, "TENANT_MISMATCH", "Tenant informado não pertence ao token", nil)
                        c.Abort()
                        return
                }</span>

                <span class="cov9" title="8">c.Set(ContextTenantIDKey, claims.TenantID)
                c.Set(ContextUserIDKey, claims.UserID)
                c.Set(ContextUserRoleKey, claims.Role)
                c.Next()</span>
        }
}
</pre>

		<pre class="file" id="file24" style="display: none">package middleware

import (
        "strings"
        "time"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// Logger emite logs estruturados para cada requisição HTTP usando o zap.Logger fornecido.
func Logger(logger *zap.Logger) gin.HandlerFunc <span class="cov10" title="3">{
        return func(c *gin.Context) </span><span class="cov10" title="3">{
                start := time.Now()
                path := c.Request.URL.Path
                query := c.Request.URL.RawQuery
                method := c.Request.Method
                proto := c.Request.Proto
                ip := c.ClientIP()
                ua := c.Request.UserAgent()
                ref := c.Request.Referer()
                bytesIn := c.Request.ContentLength
                if bytesIn &lt; 0 </span><span class="cov0" title="0">{
                        bytesIn = 0
                }</span>

                <span class="cov10" title="3">c.Next()

                latency := time.Since(start)
                status := c.Writer.Status()
                bytesOut := c.Writer.Size()
                if bytesOut &lt; 0 </span><span class="cov0" title="0">{
                        bytesOut = 0
                }</span>

                <span class="cov10" title="3">fields := []zap.Field{
                        zap.Int("status", status),
                        zap.String("method", method),
                        zap.String("path", path),
                        zap.String("proto", proto),
                        zap.String("client_ip", ip),
                        zap.String("user_agent", ua),
                        zap.Int("bytes_in", int(bytesIn)),
                        zap.Int("bytes_out", bytesOut),
                        zap.Duration("latency", latency),
                }

                if query != "" </span><span class="cov1" title="1">{
                        fields = append(fields, zap.String("query", query))
                }</span>

                <span class="cov10" title="3">if ref != "" </span><span class="cov0" title="0">{
                        fields = append(fields, zap.String("referer", ref))
                }</span>

                <span class="cov10" title="3">reqID := c.GetString(requestIDHeader)
                if reqID != "" </span><span class="cov10" title="3">{
                        fields = append(fields, zap.String("request_id", reqID))
                }</span>

                <span class="cov10" title="3">if tenantID, ok := c.Get(ContextTenantIDKey); ok </span><span class="cov6" title="2">{
                        if tenantStr, okCast := tenantID.(string); okCast &amp;&amp; tenantStr != "" </span><span class="cov6" title="2">{
                                fields = append(fields, zap.String("tenant_id", tenantStr))
                        }</span>
                }

                <span class="cov10" title="3">if userID, ok := c.Get(ContextUserIDKey); ok </span><span class="cov1" title="1">{
                        if userStr, okCast := userID.(string); okCast &amp;&amp; userStr != "" </span><span class="cov1" title="1">{
                                fields = append(fields, zap.String("user_id", userStr))
                        }</span>
                }

                <span class="cov10" title="3">if len(c.Errors) &gt; 0 </span><span class="cov0" title="0">{
                        fields = append(fields, zap.String("error", strings.Join(c.Errors.Errors(), "; ")))
                }</span>

                <span class="cov10" title="3">msg := "http_request"
                switch </span>{
                case status &gt;= 500:<span class="cov0" title="0">
                        logger.Error(msg, fields...)</span>
                case status &gt;= 400:<span class="cov1" title="1">
                        logger.Warn(msg, fields...)</span>
                default:<span class="cov6" title="2">
                        logger.Info(msg, fields...)</span>
                }
        }
}
</pre>

		<pre class="file" id="file25" style="display: none">package middleware

import (
        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

const requestIDHeader = "X-Request-ID"

// RequestID injeta um identificador único em cada requisição.
func RequestID() gin.HandlerFunc <span class="cov10" title="5">{
        return func(c *gin.Context) </span><span class="cov10" title="5">{
                reqID := c.GetHeader(requestIDHeader)
                if reqID == "" </span><span class="cov7" title="3">{
                        reqID = uuid.NewString()
                }</span>
                <span class="cov10" title="5">c.Set(requestIDHeader, reqID)
                c.Writer.Header().Set(requestIDHeader, reqID)
                c.Next()</span>
        }
}
</pre>

		<pre class="file" id="file26" style="display: none">package middleware

import (
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"

        "github.com/kusmin/gestao_updev/backend/internal/http/response"
)

var publicPrefixes = []string{
        "/v1/healthz",
        "/v1/auth/signup",
        "/v1/auth/login",
        "/v1/auth/refresh",
        "/swagger",
}

// TenantEnforcer garante que requisições autenticadas contenham o cabeçalho do tenant.
func TenantEnforcer(headerName string) gin.HandlerFunc <span class="cov5" title="9">{
        return func(c *gin.Context) </span><span class="cov6" title="12">{
                path := c.Request.URL.Path
                for _, prefix := range publicPrefixes </span><span class="cov10" title="56">{
                        if strings.HasPrefix(path, prefix) </span><span class="cov1" title="1">{
                                c.Next()
                                return
                        }</span>
                }

                <span class="cov6" title="11">if headerName == "" </span><span class="cov0" title="0">{
                        headerName = "X-Tenant-ID"
                }</span>

                <span class="cov6" title="11">tenantID := c.GetHeader(headerName)
                if tenantID == "" </span><span class="cov1" title="1">{
                        response.Error(c, http.StatusBadRequest, "TENANT_ID_REQUIRED", "Cabeçalho de tenant ausente", nil)
                        c.Abort()
                        return
                }</span>

                <span class="cov6" title="10">c.Set(ContextTenantIDKey, tenantID)
                c.Next()</span>
        }
}
</pre>

		<pre class="file" id="file27" style="display: none">package repository

import (
        "context"
        "github.com/google/uuid"
        "github.com/kusmin/gestao_updev/backend/internal/domain"
        "gorm.io/gorm"
)

type CompanyRepository struct {
        db *gorm.DB
}

func NewCompanyRepository(db *gorm.DB) *CompanyRepository <span class="cov10" title="2">{
        return &amp;CompanyRepository{db: db}
}</span>

func (r *CompanyRepository) ListAll(ctx context.Context) ([]domain.Company, error) <span class="cov0" title="0">{
        var companies []domain.Company
        if err := r.db.WithContext(ctx).Find(&amp;companies).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return companies, nil</span>
}

func (r *CompanyRepository) FindByID(ctx context.Context, id uuid.UUID) (*domain.Company, error) <span class="cov0" title="0">{
        var company domain.Company
        if err := r.db.WithContext(ctx).First(&amp;company, "id = ?", id).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;company, nil</span>
}

func (r *CompanyRepository) Create(ctx context.Context, company *domain.Company) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(company).Error
}</span>

func (r *CompanyRepository) Update(ctx context.Context, company *domain.Company) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Save(company).Error
}</span>

func (r *CompanyRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Delete(&amp;domain.Company{}, id).Error
}</span>
</pre>

		<pre class="file" id="file28" style="display: none">package repository

import (
        "context"
        "github.com/google/uuid"
        "github.com/kusmin/gestao_updev/backend/internal/domain"
        "gorm.io/gorm"
)

type ProductRepository struct {
        db *gorm.DB
}

func NewProductRepository(db *gorm.DB) *ProductRepository <span class="cov0" title="0">{
        return &amp;ProductRepository{db: db}
}</span>

func (r *ProductRepository) ListAll(ctx context.Context) ([]domain.Product, error) <span class="cov0" title="0">{
        var products []domain.Product
        if err := r.db.WithContext(ctx).Find(&amp;products).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return products, nil</span>
}

func (r *ProductRepository) FindByID(ctx context.Context, id uuid.UUID) (*domain.Product, error) <span class="cov0" title="0">{
        var product domain.Product
        if err := r.db.WithContext(ctx).First(&amp;product, "id = ?", id).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;product, nil</span>
}

func (r *ProductRepository) Create(ctx context.Context, product *domain.Product) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(product).Error
}</span>

func (r *ProductRepository) Update(ctx context.Context, product *domain.Product) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Save(product).Error
}</span>

func (r *ProductRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Delete(&amp;domain.Product{}, id).Error
}</span>
</pre>

		<pre class="file" id="file29" style="display: none">package repository

import (
        "context"

        "github.com/google/uuid"
        "gorm.io/gorm"
)

// Repository provê acesso centralizado ao banco.
type Repository struct {
        db *gorm.DB
}

// New instancia um repositório baseado no GORM.
func New(db *gorm.DB) *Repository <span class="cov6" title="10">{
        return &amp;Repository{db: db}
}</span>

// DB expõe o ponteiro cru para cenários avançados/transactions.
func (r *Repository) DB() *gorm.DB <span class="cov10" title="51">{
        return r.db
}</span>

// WithTenant injeta o filtro de tenant padrão em uma query.
func (r *Repository) WithTenant(tenantID uuid.UUID) *gorm.DB <span class="cov0" title="0">{
        return r.db.Where("tenant_id = ?", tenantID)
}</span>

// Transaction executa uma função dentro de uma transação.
func (r *Repository) Transaction(ctx context.Context, fn func(tx *gorm.DB) error) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Transaction(fn)
}</span>
</pre>

		<pre class="file" id="file30" style="display: none">package server

import (
        "context"
        "errors"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "go.opentelemetry.io/contrib/instrumentation/github.com/gin-gonic/gin/otelgin"
        "go.uber.org/zap"
        "gorm.io/gorm"

        _ "github.com/kusmin/gestao_updev/backend/docs"
        "github.com/kusmin/gestao_updev/backend/internal/auth"
        "github.com/kusmin/gestao_updev/backend/internal/config"
        "github.com/kusmin/gestao_updev/backend/internal/http/handler"
        "github.com/kusmin/gestao_updev/backend/internal/http/response"
        "github.com/kusmin/gestao_updev/backend/internal/middleware"
        "github.com/kusmin/gestao_updev/backend/internal/repository"
        "github.com/kusmin/gestao_updev/backend/internal/service"
        "github.com/kusmin/gestao_updev/backend/pkg/telemetry"
        swaggerFiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"
)

// Server representa a API HTTP.
type Server struct {
        cfg       *config.Config
        logger    *zap.Logger
        engine    *gin.Engine
        db        *gorm.DB
        telemetry *telemetry.Telemetry
}

// New cria uma instância do servidor HTTP.
func New(cfg *config.Config, logger *zap.Logger, db *gorm.DB, telem *telemetry.Telemetry) *Server <span class="cov10" title="2">{
        if cfg.AppEnv == "production" </span><span class="cov0" title="0">{
                gin.SetMode(gin.ReleaseMode)
        }</span>

        <span class="cov10" title="2">engine := gin.New()
        engine.Use(gin.Recovery())
        engine.Use(middleware.RequestID())
        if telem != nil &amp;&amp; telem.TracerProvider() != nil </span><span class="cov0" title="0">{
                engine.Use(otelgin.Middleware(cfg.ServiceName, otelgin.WithTracerProvider(telem.TracerProvider())))
        }</span>
        <span class="cov0" title="0">engine.Use(middleware.Logger(logger))

        // Repositories
        repo := repository.New(db)
        companyRepo := repository.NewCompanyRepository(db)

        // Services
        jwtManager := auth.NewJWTManager(cfg.JWTAccessSecret, cfg.JWTRefreshSecret, cfg.JWTAccessTTL, cfg.JWTRefreshTTL)
        svc := service.New(cfg, repo, jwtManager, logger)
        companySvc := service.NewCompanyService(companyRepo)

        // Handlers
</span>        apiHandler := handler.New(svc, logger)
        companyHandler := handler.NewCompanyHandler(companySvc)

        api := engine.Group("/v1")
        api.Use(middleware.TenantEnforcer(cfg.TenantHeader))
        registerRoutes(api, cfg, apiHandler, companyHandler, jwtManager)

        engine.GET("/v1/healthz", func(c *gin.Context) </span></span></span></span></span>{
                response.Success(c, http.StatusOK, gin.H{
</span>                        "status": "ok",
                        "env":    cfg.AppEnv,
                }, nil)
        }</span></span>)

        engine.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

        if telem != nil &amp;&amp; telem.MetricsHandler() != nil &amp;&amp; cfg.MetricsRoute != "" {
                engine.GET(cfg.MetricsRoute, gin.WrapH(telem.MetricsHandler()))
        }</span></span></span>

        <span class="cov10" title="2">return &amp;Server{
                cfg:       cfg,
                logger:    logger,
                engine:    engine,
                db:        db,
                telemetry: telem,
        }</span>
}

// Run inicia o servidor HTTP e bloqueia até receber sinal de desligamento.
func (s *Se</span><span class="cov0" title="0">rver) Run(ctx context.Context) error {
        httpSrv := &amp;http.Server{
                Addr:    s.cfg.Address(),
</span>                Handler: s.engine,
        }

        errCh := make(chan error, 1)

        go func() </span></span></span><span class="cov0" title="0">{
                s.logger.Info("HTTP server starting", zap.String("addr", s.cfg.Address()))
                if err := httpSrv.ListenAndServe(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span>{
                        errCh &lt;- err
                }
</span></span>        }()

</span>        <span class="cov0" title="0">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                s.logger.Info("shutting down server")
                shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
                defer cancel()
                return httpSrv.Shutdown(shutdownCtx)</span>
        case err := &lt;-errCh:
                return err
        }
}

func registerRoutes(api *gin.RouterGroup, cfg *config.Config, h *handler.API, companyHandler *handler.CompanyHandler, jwtManager *auth.JWTManager) {
        authGroup := api.Group("/auth")
        authGroup.POST("/signup", h.Signup)
        authGroup.POST("/login", h.Login)
        authGroup.POST("/refresh", h.RefreshToken)

        protected := api.Group("/")
        protected.Use(middleware.Auth(jwtManager, cfg.TenantHeader))

        protected.GET("/companies/me", h.GetCompany)
        protected.PUT("/companies/me", h.UpdateCompany)

        protected.GET("/users", h.ListUsers)
        protected.POST("/users", h.CreateUser)
        protected.GET("/users/:id", h.GetUser)
        protected.PATCH("/users/:id", h.UpdateUser)
        protected.DELETE("/users/:id", h.DeleteUser)

        protected.GET("/clients", h.ListClients)
        protected.POST("/clients", h.CreateClient)
        protected.GET("/clients/:id", h.GetClient)
        protected.PUT("/clients/:id", h.UpdateClient)
        protected.DELETE("/clients/:id", h.DeleteClient)

        protected.GET("/professionals", h.ListProfessionals)

        protected.GET("/services", h.ListServices)
        protected.POST("/services", h.CreateService)
        protected.GET("/services/:id", h.GetService)
        protected.PUT("/services/:id", h.UpdateService)
        protected.DELETE("/services/:id", h.DeleteService)

        protected.GET("/products", h.ListProducts)
        protected.POST("/products", h.CreateProduct)
        protected.GET("/products/:id", h.GetProduct)
        protected.PUT("/products/:id", h.UpdateProduct)
        protected.DELETE("/products/:id", h.DeleteProduct)

        protected.GET("/inventory/movements", h.ListInventoryMovements)
        protected.POST("/inventory/movements", h.CreateInventoryMovement)

        protected.GET("/bookings", h.ListBookings)
        protected.POST("/bookings", h.CreateBooking)
        protected.PATCH("/bookings/:id", h.UpdateBooking)
        protected.POST("/bookings/:id/cancel", h.CancelBooking)

</span></span>        protected.GET("/sales/orders", h.ListSalesOrders)
        protected.POST("/sales/orders", h.CreateSalesOrder)
        protected.PATCH("/sales/orders/:id", h.UpdateSalesOrder)
        protected.POST("/sales/orders/:id/payments", h.CreatePayment)
        protected.GET("/payments", h.ListPayments)

        protected.GET("/dashboard/daily", h.DashboardDaily)

        // Admin routes
        admin := api.Group("/admin")
        admin.Use(middleware.Auth(jwtManager, cfg.TenantHeader), middleware.Admin())
        companyHandler.RegisterRoutes(admin)
        h.RegisterAdminUserRoutes(admin)
        h.RegisterAdminProductRoutes(admin)
}</span></span></span>
</pre>

		<pre class="file" id="file31" style="display: none">package service

import (
        "context"
        "time"

        "github.com/google/uuid"
        "golang.org/x/crypto/bcrypt"
        "gorm.io/gorm"

        "github.com/kusmin/gestao_updev/backend/internal/auth"
        "github.com/kusmin/gestao_updev/backend/internal/domain"
)

// SignupInput representa os dados necessários para criar uma empresa.
type SignupInput struct {
        CompanyName     string
        CompanyDocument string
        CompanyPhone    string
        UserName        string
        UserEmail       string
        UserPassword    string
        UserPhone       string
}

// SignupResult é o retorno padrão do fluxo de cadastro.
type SignupResult struct {
        TenantID uuid.UUID
        UserID   uuid.UUID
        Tokens   *auth.TokenPair
}

// Signup cria a empresa, usuário admin e retorna os tokens iniciais.
func (s *Service) Signup(ctx context.Context, input SignupInput) (*SignupResult, error) <span class="cov0" title="0">{
        passwordHash, err := bcrypt.GenerateFromPassword([]byte(input.UserPassword), s.cfg.BcryptCost)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">company := &amp;domain.Company{
                Name:     input.CompanyName,
                Document: input.CompanyDocument,
                Phone:    input.CompanyPhone,
        }

        user := &amp;domain.User{
                Name:         input.UserName,
                Email:        s.sanitizeEmail(input.UserEmail),
                Phone:        input.UserPhone,
                Role:         "admin",
                PasswordHash: string(passwordHash),
                Active:       true,
        }

        err = s.repo.DB().WithContext(ctx).Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                if err := tx.Create(company).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">user.TenantID = company.ID
                if err := tx.Create(user).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tokenPair, err := s.jwt.GenerateTokens(user.ID.String(), company.ID.String(), user.Role)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;SignupResult{
                TenantID: company.ID,
                UserID:   user.ID,
                Tokens:   tokenPair,
        }, nil</span>
}

// Login realiza autenticação via email/senha e retorna os tokens.
func (s *Service) Login(ctx context.Context, email, password string) (*domain.User, *auth.TokenPair, error) <span class="cov0" title="0">{
        var user domain.User
        if err := s.dbWithContext(ctx).
                Where("lower(email) = ?", s.sanitizeEmail(email)).
                First(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, nil, ErrInvalidCredentials
                }</span>
                <span class="cov0" title="0">return nil, nil, err</span>
        }

        <span class="cov0" title="0">if !user.Active </span><span class="cov0" title="0">{
                return nil, nil, ErrInvalidCredentials
        }</span>

        <span class="cov0" title="0">if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(password)); err != nil </span><span class="cov0" title="0">{
                return nil, nil, ErrInvalidCredentials
        }</span>

        <span class="cov0" title="0">tokenPair, err := s.jwt.GenerateTokens(user.ID.String(), user.TenantID.String(), user.Role)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">now := time.Now()
        _ = s.dbWithContext(ctx).Model(&amp;user).Update("last_login_at", now).Error

        return &amp;user, tokenPair, nil</span>
}

// RefreshTokens valida o refresh token e devolve novos tokens.
func (s *Service) RefreshTokens(ctx context.Context, refreshToken string) (*auth.TokenPair, error) <span class="cov0" title="0">{
        claims, err := s.jwt.ValidateRefreshToken(refreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidCredentials
        }</span>

        <span class="cov0" title="0">var user domain.User
        if err := s.dbWithContext(ctx).
                Where("id = ?", claims.UserID).
                First(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, ErrInvalidCredentials
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">if !user.Active </span><span class="cov0" title="0">{
                return nil, ErrInvalidCredentials
        }</span>

        <span class="cov0" title="0">tokenPair, err := s.jwt.GenerateTokens(user.ID.String(), user.TenantID.String(), user.Role)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return tokenPair, nil</span>
}
</pre>

		<pre class="file" id="file32" style="display: none">package service

import (
        "context"
        "errors"
        "time"

        "github.com/google/uuid"
        "gorm.io/datatypes"
        "gorm.io/gorm"

        "github.com/kusmin/gestao_updev/backend/internal/domain"
)

// BookingFilter define filtros básicos.
type BookingFilter struct {
        Date           *time.Time
        ProfessionalID *uuid.UUID
        Status         string
}

// BookingInput dados obrigatórios para criação.
type BookingInput struct {
        ClientID       uuid.UUID
        ProfessionalID uuid.UUID
        ServiceID      uuid.UUID
        Status         string
        StartAt        time.Time
        EndAt          *time.Time
        Notes          string
}

// BookingUpdateInput campos permitidos na edição.
type BookingUpdateInput struct {
        Status  *string
        StartAt *time.Time
        EndAt   *time.Time
        Notes   *string
}

var ErrBookingConflict = errors.New("já existe agendamento no horário selecionado")

func (s *Service) ListBookings(ctx context.Context, tenantID uuid.UUID, filter BookingFilter) ([]domain.Booking, error) <span class="cov0" title="0">{
        query := s.dbWithContext(ctx).
                Where("tenant_id = ?", tenantID)

        if filter.Status != "" </span><span class="cov0" title="0">{
                query = query.Where("status = ?", filter.Status)
        }</span>
        <span class="cov0" title="0">if filter.ProfessionalID != nil </span><span class="cov0" title="0">{
                query = query.Where("professional_id = ?", *filter.ProfessionalID)
        }</span>
        <span class="cov0" title="0">if filter.Date != nil </span><span class="cov0" title="0">{
                start := filter.Date.Truncate(24 * time.Hour)
                end := start.Add(24 * time.Hour)
                query = query.Where("start_at &gt;= ? AND start_at &lt; ?", start, end)
        }</span>

        <span class="cov0" title="0">var bookings []domain.Booking
        if err := query.Order("start_at ASC").Find(&amp;bookings).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return bookings, nil</span>
}

func (s *Service) CreateBooking(ctx context.Context, tenantID uuid.UUID, input BookingInput) (*domain.Booking, error) <span class="cov8" title="1">{
        if err := s.ensureTenantRecord(ctx, &amp;domain.Client{}, tenantID, input.ClientID); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := s.ensureTenantRecord(ctx, &amp;domain.Professional{}, tenantID, input.ProfessionalID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if input.Status == "" </span><span class="cov0" title="0">{
                input.Status = domain.BookingStatusPending
        }</span>

        <span class="cov0" title="0">start := input.StartAt
        end := input.EndAt
        if end == nil || end.Before(start) </span><span class="cov0" title="0">{
                var service domain.Service
                if err := s.dbWithContext(ctx).First(&amp;service, "tenant_id = ? AND id = ?", tenantID, input.ServiceID).Error; err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">calculated := start.Add(time.Duration(service.DurationMinutes) * time.Minute)
                end = &amp;calculated</span>
        }

        <span class="cov0" title="0">if err := s.checkBookingConflict(ctx, tenantID, input.ProfessionalID, start, *end, nil); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">booking := &amp;domain.Booking{
                TenantModel: domain.TenantModel{
                        TenantID: tenantID,
                },
                ClientID:       input.ClientID,
                ProfessionalID: input.ProfessionalID,
                ServiceID:      input.ServiceID,
                Status:         input.Status,
                StartAt:        start,
                EndAt:          *end,
                Notes:          input.Notes,
                Metadata:       datatypes.JSONMap{},
        }

        if err := s.dbWithContext(ctx).Create(booking).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return booking, nil</span>
}

func (s *Service) UpdateBooking(ctx context.Context, tenantID, bookingID uuid.UUID, input BookingUpdateInput) (*domain.Booking, error) <span class="cov0" title="0">{
        var booking domain.Booking
        if err := s.dbWithContext(ctx).
                Where("tenant_id = ? AND id = ?", tenantID, bookingID).
                First(&amp;booking).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if input.StartAt != nil || input.EndAt != nil </span><span class="cov0" title="0">{
                start := booking.StartAt
                end := booking.EndAt
                if input.StartAt != nil </span><span class="cov0" title="0">{
                        start = *input.StartAt
                }</span>
                <span class="cov0" title="0">if input.EndAt != nil </span><span class="cov0" title="0">{
                        end = *input.EndAt
                }</span>
                <span class="cov0" title="0">if err := s.checkBookingConflict(ctx, tenantID, booking.ProfessionalID, start, end, &amp;booking.ID); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">updates := map[string]interface{}{}
        if input.Status != nil </span><span class="cov0" title="0">{
                updates["status"] = *input.Status
        }</span>
        <span class="cov0" title="0">if input.StartAt != nil </span><span class="cov0" title="0">{
                updates["start_at"] = *input.StartAt
        }</span>
        <span class="cov0" title="0">if input.EndAt != nil </span><span class="cov0" title="0">{
                updates["end_at"] = *input.EndAt
        }</span>
        <span class="cov0" title="0">if input.Notes != nil </span><span class="cov0" title="0">{
                updates["notes"] = *input.Notes
        }</span>

        <span class="cov0" title="0">if len(updates) == 0 </span><span class="cov0" title="0">{
                return &amp;booking, nil
        }</span>

        <span class="cov0" title="0">if err := s.dbWithContext(ctx).
                Model(&amp;domain.Booking{}).
                Where("tenant_id = ? AND id = ?", tenantID, bookingID).
                Updates(updates).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.dbWithContext(ctx).
                Where("tenant_id = ? AND id = ?", tenantID, bookingID).
                First(&amp;booking).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;booking, nil</span>
}

func (s *Service) CancelBooking(ctx context.Context, tenantID, bookingID uuid.UUID, reason string) (*domain.Booking, error) <span class="cov0" title="0">{
        var booking domain.Booking
        if err := s.dbWithContext(ctx).
                Where("tenant_id = ? AND id = ?", tenantID, bookingID).
                First(&amp;booking).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">metadata := booking.Metadata
        if metadata == nil </span><span class="cov0" title="0">{
                metadata = datatypes.JSONMap{}
        }</span>
        <span class="cov0" title="0">if reason != "" </span><span class="cov0" title="0">{
                metadata["cancel_reason"] = reason
        }</span>

        <span class="cov0" title="0">if err := s.dbWithContext(ctx).
                Model(&amp;domain.Booking{}).
                Where("tenant_id = ? AND id = ?", tenantID, bookingID).
                Updates(map[string]interface{}{
                        "status":   domain.BookingStatusCanceled,
                        "metadata": metadata,
                }).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.dbWithContext(ctx).
                Where("tenant_id = ? AND id = ?", tenantID, bookingID).
                First(&amp;booking).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;booking, nil</span>
}

func (s *Service) checkBookingConflict(ctx context.Context, tenantID, professionalID uuid.UUID, start, end time.Time, ignoreID *uuid.UUID) error <span class="cov0" title="0">{
        query := s.dbWithContext(ctx).
                Model(&amp;domain.Booking{}).
                Where("tenant_id = ? AND professional_id = ? AND status != ?", tenantID, professionalID, domain.BookingStatusCanceled).
                Where("start_at &lt; ? AND end_at &gt; ?", end, start)

        if ignoreID != nil </span><span class="cov0" title="0">{
                query = query.Where("id &lt;&gt; ?", *ignoreID)
        }</span>

        <span class="cov0" title="0">var conflict domain.Booking
        if err := query.First(&amp;conflict).Error; err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">return ErrBookingConflict</span>
}
</pre>

		<pre class="file" id="file33" style="display: none">package service

import (
        "context"

        "github.com/google/uuid"
        "gorm.io/datatypes"

        "github.com/kusmin/gestao_updev/backend/internal/domain"
)

// ServiceInput representa payload de serviços.
type ServiceInput struct {
        Name            string
        Category        string
        Description     string
        DurationMinutes int
        Price           float64
        Color           string
        Metadata        map[string]interface{}
}

// ProductInput representa payload de produtos.
type ProductInput struct {
        Name        string
        SKU         string
        Price       float64
        Cost        float64
        StockQty    int
        MinStock    int
        Description string
        Metadata    map[string]interface{}
}

func (s *Service) ListServices(ctx context.Context, tenantID uuid.UUID) ([]domain.Service, error) <span class="cov1" title="1">{
        var services []domain.Service
        if err := s.dbWithContext(ctx).
                Where("tenant_id = ?", tenantID).
                Order("name ASC").
                Find(&amp;services).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return services, nil</span>
}

func (s *Service) GetService(ctx context.Context, tenantID, serviceID uuid.UUID) (*domain.Service, error) <span class="cov7" title="4">{
        var service domain.Service
        if err := s.dbWithContext(ctx).
                Where("tenant_id = ? AND id = ?", tenantID, serviceID).
                First(&amp;service).Error; err != nil </span><span class="cov6" title="3">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return &amp;service, nil</span>
}

func (s *Service) CreateService(ctx context.Context, tenantID uuid.UUID, input ServiceInput) (*domain.Service, error) <span class="cov10" title="6">{
        service := &amp;domain.Service{
                TenantModel: domain.TenantModel{
                        TenantID: tenantID,
                },
                Name:            input.Name,
                Category:        input.Category,
                Description:     input.Description,
                DurationMinutes: input.DurationMinutes,
                Price:           input.Price,
                Color:           input.Color,
                Metadata:        datatypes.JSONMap(input.Metadata),
        }
        if err := s.dbWithContext(ctx).Create(service).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="6">return service, nil</span>
}

func (s *Service) UpdateService(ctx context.Context, tenantID, serviceID uuid.UUID, input ServiceInput) (*domain.Service, error) <span class="cov1" title="1">{
        var service domain.Service
        if err := s.dbWithContext(ctx).
                Where("tenant_id = ? AND id = ?", tenantID, serviceID).
                First(&amp;service).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">updates := map[string]interface{}{
                "name":             input.Name,
                "category":         input.Category,
                "description":      input.Description,
                "duration_minutes": input.DurationMinutes,
                "price":            input.Price,
                "color":            input.Color,
                "metadata":         datatypes.JSONMap(input.Metadata),
        }

        if err := s.dbWithContext(ctx).
                Model(&amp;domain.Service{}).
                Where("tenant_id = ? AND id = ?", tenantID, serviceID).
                Updates(updates).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if err := s.dbWithContext(ctx).
                Where("tenant_id = ? AND id = ?", tenantID, serviceID).
                First(&amp;service).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return &amp;service, nil</span>
}

func (s *Service) DeleteService(ctx context.Context, tenantID, serviceID uuid.UUID) error <span class="cov1" title="1">{
        return s.dbWithContext(ctx).
                Where("tenant_id = ? AND id = ?", tenantID, serviceID).
                Delete(&amp;domain.Service{}).Error
}</span>

func (s *Service) ListProducts(ctx context.Context, tenantID uuid.UUID) ([]domain.Product, error) <span class="cov1" title="1">{
        var products []domain.Product
        if err := s.dbWithContext(ctx).
                Where("tenant_id = ?", tenantID).
                Order("name ASC").
                Find(&amp;products).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return products, nil</span>
}

func (s *Service) GetProduct(ctx context.Context, tenantID, productID uuid.UUID) (*domain.Product, error) <span class="cov7" title="4">{
        var product domain.Product
        if err := s.dbWithContext(ctx).
                Where("tenant_id = ? AND id = ?", tenantID, productID).
                First(&amp;product).Error; err != nil </span><span class="cov6" title="3">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return &amp;product, nil</span>
}

func (s *Service) CreateProduct(ctx context.Context, tenantID uuid.UUID, input ProductInput) (*domain.Product, error) <span class="cov10" title="6">{
        product := &amp;domain.Product{
                TenantModel: domain.TenantModel{
                        TenantID: tenantID,
                },
                Name:        input.Name,
                SKU:         input.SKU,
                Price:       input.Price,
                Cost:        input.Cost,
                StockQty:    input.StockQty,
                MinStock:    input.MinStock,
                Description: input.Description,
                Metadata:    datatypes.JSONMap(input.Metadata),
        }
        if err := s.dbWithContext(ctx).Create(product).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="6">return product, nil</span>
}

func (s *Service) UpdateProduct(ctx context.Context, tenantID, productID uuid.UUID, input ProductInput) (*domain.Product, error) <span class="cov1" title="1">{
        var product domain.Product
        if err := s.dbWithContext(ctx).
                Where("tenant_id = ? AND id = ?", tenantID, productID).
                First(&amp;product).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">updates := map[string]interface{}{
                "name":        input.Name,
                "sku":         input.SKU,
                "price":       input.Price,
                "cost":        input.Cost,
                "stock_qty":   input.StockQty,
                "min_stock":   input.MinStock,
                "description": input.Description,
                "metadata":    datatypes.JSONMap(input.Metadata),
        }

        if err := s.dbWithContext(ctx).
                Model(&amp;domain.Product{}).
                Where("tenant_id = ? AND id = ?", tenantID, productID).
                Updates(updates).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if err := s.dbWithContext(ctx).
                Where("tenant_id = ? AND id = ?", tenantID, productID).
                First(&amp;product).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return &amp;product, nil</span>
}

func (s *Service) DeleteProduct(ctx context.Context, tenantID, productID uuid.UUID) error <span class="cov1" title="1">{
        return s.dbWithContext(ctx).
                Where("tenant_id = ? AND id = ?", tenantID, productID).
                Delete(&amp;domain.Product{}).Error
}</span>

func (s *Service) ListAllProducts(ctx context.Context) ([]domain.Product, error) <span class="cov0" title="0">{
        var products []domain.Product
        if err := s.dbWithContext(ctx).
                Order("name ASC").
                Find(&amp;products).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return products, nil</span>
}

type AdminProductInput struct {
        ProductInput
        TenantID uuid.UUID
}

func (s *Service) AdminCreateProduct(ctx context.Context, input AdminProductInput) (*domain.Product, error) <span class="cov0" title="0">{
        product := &amp;domain.Product{
                TenantModel: domain.TenantModel{
                        TenantID: input.TenantID,
                },
                Name:        input.Name,
                SKU:         input.SKU,
                Price:       input.Price,
                Cost:        input.Cost,
                StockQty:    input.StockQty,
                MinStock:    input.MinStock,
                Description: input.Description,
                Metadata:    datatypes.JSONMap(input.Metadata),
        }
        if err := s.dbWithContext(ctx).Create(product).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return product, nil</span>
}

func (s *Service) AdminUpdateProduct(ctx context.Context, productID uuid.UUID, input ProductInput) (*domain.Product, error) <span class="cov0" title="0">{
        var product domain.Product
        if err := s.dbWithContext(ctx).
                First(&amp;product, "id = ?", productID).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">updates := map[string]interface{}{
                "name":        input.Name,
                "sku":         input.SKU,
                "price":       input.Price,
                "cost":        input.Cost,
                "stock_qty":   input.StockQty,
                "min_stock":   input.MinStock,
                "description": input.Description,
                "metadata":    datatypes.JSONMap(input.Metadata),
        }

        if err := s.dbWithContext(ctx).
                Model(&amp;domain.Product{}).
                Where("id = ?", productID).
                Updates(updates).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.dbWithContext(ctx).
                First(&amp;product, "id = ?", productID).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;product, nil</span>
}

func (s *Service) AdminDeleteProduct(ctx context.Context, productID uuid.UUID) error <span class="cov0" title="0">{
        return s.dbWithContext(ctx).
                Delete(&amp;domain.Product{}, "id = ?", productID).Error
}</span>

</pre>

		<pre class="file" id="file34" style="display: none">package service

import (
        "context"
        "encoding/json"
        "time"

        "github.com/google/uuid"
        "gorm.io/datatypes"
        "gorm.io/gorm"

        "github.com/kusmin/gestao_updev/backend/internal/domain"
)

// ClientsFilter define filtros disponíveis.
type ClientsFilter struct {
        Search  string
        Tags    []string
        Page    int
        PerPage int
}

// ClientInput concentra dados editáveis.
type ClientInput struct {
        Name    string
        Email   string
        Phone   string
        Notes   string
        Tags    []string
        Contact map[string]interface{}
}

// ClientStats agrega dados de histórico.
type ClientStats struct {
        TotalBookings int64      `json:"total_bookings"`
        TotalSpent    float64    `json:"total_spent"`
        LastBooking   *time.Time `json:"last_booking"`
}

// ListClients retorna clientes com paginação/filtros básicos.
func (s *Service) ListClients(ctx context.Context, tenantID uuid.UUID, filter ClientsFilter) ([]domain.Client, int64, error) <span class="cov0" title="0">{
        var clients []domain.Client
        var total int64

        page, perPage := s.clampPagination(filter.Page, filter.PerPage)

        query := s.dbWithContext(ctx).
                Model(&amp;domain.Client{}).
                Where("tenant_id = ?", tenantID)

        if filter.Search != "" </span><span class="cov0" title="0">{
                like := "%" + filter.Search + "%"
                query = query.Where("(name ILIKE ? OR email ILIKE ? OR phone ILIKE ?)", like, like, like)
        }</span>

        <span class="cov0" title="0">for _, tag := range filter.Tags </span><span class="cov0" title="0">{
                tagJSON, _ := json.Marshal([]string{tag})
                query = query.Where("tags @&gt; ?", datatypes.JSON(tagJSON))
        }</span>

        <span class="cov0" title="0">if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">if total == 0 </span><span class="cov0" title="0">{
                return []domain.Client{}, 0, nil
        }</span>

        <span class="cov0" title="0">if err := query.
                Order("created_at DESC").
                Limit(perPage).
                Offset((page - 1) * perPage).
                Find(&amp;clients).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return clients, total, nil</span>
}

// CreateClient adiciona um novo cliente.
func (s *Service) CreateClient(ctx context.Context, tenantID uuid.UUID, input ClientInput) (*domain.Client, error) <span class="cov0" title="0">{
        client := &amp;domain.Client{
                TenantModel: domain.TenantModel{
                        TenantID: tenantID,
                },
                Name:    input.Name,
                Email:   input.Email,
                Phone:   input.Phone,
                Notes:   input.Notes,
                Tags:    marshalTags(input.Tags),
                Contact: marshalContact(input.Contact),
        }
        if err := s.dbWithContext(ctx).Create(client).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return client, nil</span>
}

// GetClient retorna cliente + estatísticas básicas.
func (s *Service) GetClient(ctx context.Context, tenantID, clientID uuid.UUID) (*domain.Client, *ClientStats, error) <span class="cov0" title="0">{
        var client domain.Client
        if err := s.dbWithContext(ctx).
                Where("tenant_id = ? AND id = ?", tenantID, clientID).
                First(&amp;client).Error; err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">var stats ClientStats

        err := s.dbWithContext(ctx).
                Model(&amp;domain.Booking{}).
                Where("tenant_id = ? AND client_id = ?", tenantID, clientID).
                Count(&amp;stats.TotalBookings).Error
        if err != nil </span><span class="cov0" title="0">{
                return &amp;client, nil, err
        }</span>

        <span class="cov0" title="0">var lastBooking domain.Booking
        if err := s.dbWithContext(ctx).
                Where("tenant_id = ? AND client_id = ?", tenantID, clientID).
                Order("start_at DESC").
                First(&amp;lastBooking).Error; err == nil </span><span class="cov0" title="0">{
                stats.LastBooking = &amp;lastBooking.StartAt
        }</span> else<span class="cov0" title="0"> if err != gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                return &amp;client, nil, err
        }</span>

        <span class="cov0" title="0">type totalSpent struct {
                Sum float64
        }
        var ts totalSpent
        if err := s.dbWithContext(ctx).
                Model(&amp;domain.Payment{}).
                Select("COALESCE(SUM(amount),0) AS sum").
                Joins("JOIN sales_orders so ON so.id = payments.order_id").
                Where("payments.tenant_id = ? AND so.client_id = ?", tenantID, clientID).
                Scan(&amp;ts).Error; err != nil </span><span class="cov0" title="0">{
                return &amp;client, nil, err
        }</span>
        <span class="cov0" title="0">stats.TotalSpent = ts.Sum

        return &amp;client, &amp;stats, nil</span>
}

// UpdateClient realiza alterações completas.
func (s *Service) UpdateClient(ctx context.Context, tenantID, clientID uuid.UUID, input ClientInput) (*domain.Client, error) <span class="cov0" title="0">{
        var client domain.Client
        if err := s.dbWithContext(ctx).
                Where("tenant_id = ? AND id = ?", tenantID, clientID).
                First(&amp;client).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">updates := map[string]interface{}{
                "name":    input.Name,
                "email":   input.Email,
                "phone":   input.Phone,
                "notes":   input.Notes,
                "contact": marshalContact(input.Contact),
                "tags":    marshalTags(input.Tags),
        }

        if err := s.dbWithContext(ctx).
                Model(&amp;domain.Client{}).
                Where("tenant_id = ? AND id = ?", tenantID, clientID).
                Updates(updates).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.dbWithContext(ctx).
                Where("tenant_id = ? AND id = ?", tenantID, clientID).
                First(&amp;client).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;client, nil</span>
}

// DeleteClient faz soft delete.
func (s *Service) DeleteClient(ctx context.Context, tenantID, clientID uuid.UUID) error <span class="cov0" title="0">{
        return s.dbWithContext(ctx).
                Where("tenant_id = ? AND id = ?", tenantID, clientID).
                Delete(&amp;domain.Client{}).Error
}</span>

func marshalTags(tags []string) datatypes.JSON <span class="cov0" title="0">{
        if tags == nil </span><span class="cov0" title="0">{
                return datatypes.JSON([]byte("[]"))
        }</span>
        <span class="cov0" title="0">b, _ := json.Marshal(tags)
        return datatypes.JSON(b)</span>
}

func marshalContact(contact map[string]interface{}) datatypes.JSONMap <span class="cov0" title="0">{
        if contact == nil </span><span class="cov0" title="0">{
                return datatypes.JSONMap{}
        }</span>
        <span class="cov0" title="0">return datatypes.JSONMap(contact)</span>
}
</pre>

		<pre class="file" id="file35" style="display: none">package service

import (
        "context"

        "github.com/google/uuid"

        "github.com/kusmin/gestao_updev/backend/internal/domain"
)

// CompanyUpdateInput representa campos editáveis da empresa.
type CompanyUpdateInput struct {
        Name     *string
        Timezone *string
        Phone    *string
        Email    *string
        Settings map[string]interface{}
}

// GetCompany retorna dados da empresa corrente (tenant).
func (s *Service) GetCompany(ctx context.Context, tenantID uuid.UUID) (*domain.Company, error) <span class="cov0" title="0">{
        var company domain.Company
        if err := s.dbWithContext(ctx).First(&amp;company, "id = ?", tenantID).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;company, nil</span>
}

// UpdateCompany aplica mudanças parciais nos dados da empresa.
func (s *Service) UpdateCompany(ctx context.Context, tenantID uuid.UUID, input CompanyUpdateInput) (*domain.Company, error) <span class="cov0" title="0">{
        var company domain.Company
        if err := s.dbWithContext(ctx).First(&amp;company, "id = ?", tenantID).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">updates := map[string]interface{}{}
        if input.Name != nil </span><span class="cov0" title="0">{
                updates["name"] = *input.Name
        }</span>
        <span class="cov0" title="0">if input.Timezone != nil </span><span class="cov0" title="0">{
                updates["timezone"] = *input.Timezone
        }</span>
        <span class="cov0" title="0">if input.Phone != nil </span><span class="cov0" title="0">{
                updates["phone"] = *input.Phone
        }</span>
        <span class="cov0" title="0">if input.Email != nil </span><span class="cov0" title="0">{
                updates["email"] = *input.Email
        }</span>
        <span class="cov0" title="0">if input.Settings != nil </span><span class="cov0" title="0">{
                updates["settings"] = input.Settings
        }</span>

        <span class="cov0" title="0">if len(updates) == 0 </span><span class="cov0" title="0">{
                return &amp;company, nil
        }</span>

        <span class="cov0" title="0">if err := s.dbWithContext(ctx).
                Model(&amp;domain.Company{}).
                Where("id = ?", tenantID).
                Updates(updates).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.dbWithContext(ctx).First(&amp;company, "id = ?", tenantID).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;company, nil</span>
}
</pre>

		<pre class="file" id="file36" style="display: none">package service

import (
        "context"
        "github.com/google/uuid"
        "github.com/kusmin/gestao_updev/backend/internal/domain"
        "github.com/kusmin/gestao_updev/backend/internal/repository"
)

type CompanyService struct {
        repo *repository.CompanyRepository
}

func NewCompanyService(repo *repository.CompanyRepository) *CompanyService <span class="cov10" title="2">{
        return &amp;CompanyService{repo: repo}
}</span>

func (s *CompanyService) ListAllCompanies(ctx context.Context) ([]domain.Company, error) <span class="cov0" title="0">{
        return s.repo.ListAll(ctx)
}</span>

func (s *CompanyService) GetCompanyByID(ctx context.Context, id uuid.UUID) (*domain.Company, error) <span class="cov0" title="0">{
        return s.repo.FindByID(ctx, id)
}</span>

type CreateCompanyInput struct {
        Name     string `json:"name" binding:"required"`
        Document string `json:"document"`
        Phone    string `json:"phone"`
        Email    string `json:"email"`
}

func (s *CompanyService) CreateCompany(ctx context.Context, input CreateCompanyInput) (*domain.Company, error) <span class="cov0" title="0">{
        company := &amp;domain.Company{
                Name:     input.Name,
                Document: input.Document,
                Phone:    input.Phone,
                Email:    input.Email,
        }

        if err := s.repo.Create(ctx, company); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return company, nil</span>
}

type UpdateCompanyInput struct {
        Name     string `json:"name"`
        Document string `json:"document"`
        Phone    string `json:"phone"`
        Email    string `json:"email"`
}

func (s *CompanyService) UpdateCompany(ctx context.Context, id uuid.UUID, input UpdateCompanyInput) (*domain.Company, error) <span class="cov0" title="0">{
        company, err := s.repo.FindByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if input.Name != "" </span><span class="cov0" title="0">{
                company.Name = input.Name
        }</span>
        <span class="cov0" title="0">if input.Document != "" </span><span class="cov0" title="0">{
                company.Document = input.Document
        }</span>
        <span class="cov0" title="0">if input.Phone != "" </span><span class="cov0" title="0">{
                company.Phone = input.Phone
        }</span>
        <span class="cov0" title="0">if input.Email != "" </span><span class="cov0" title="0">{
                company.Email = input.Email
        }</span>

        <span class="cov0" title="0">if err := s.repo.Update(ctx, company); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return company, nil</span>
}

func (s *CompanyService) DeleteCompany(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return s.repo.Delete(ctx, id)
}</span>
</pre>

		<pre class="file" id="file37" style="display: none">package service

import (
        "context"
        "time"

        "github.com/google/uuid"

        "github.com/kusmin/gestao_updev/backend/internal/domain"
)

// DashboardDailyDTO estrutura retorno do endpoint.
type DashboardDailyDTO struct {
        Date        string       `json:"date"`
        Bookings    int64        `json:"bookings"`
        Completed   int64        `json:"completed"`
        Revenue     float64      `json:"revenue"`
        TopServices []TopService `json:"top_services"`
}

// TopService agrega ranking diário.
type TopService struct {
        ServiceID uuid.UUID `json:"service_id"`
        Name      string    `json:"name"`
        Quantity  int64     `json:"quantity"`
}

func (s *Service) DashboardDaily(ctx context.Context, tenantID uuid.UUID, date time.Time, professionalID *uuid.UUID) (*DashboardDailyDTO, error) <span class="cov0" title="0">{
        start := date.Truncate(24 * time.Hour)
        end := start.Add(24 * time.Hour)

        bookingQuery := s.dbWithContext(ctx).Model(&amp;domain.Booking{}).
                Where("tenant_id = ? AND start_at &gt;= ? AND start_at &lt; ?", tenantID, start, end)
        if professionalID != nil </span><span class="cov0" title="0">{
                bookingQuery = bookingQuery.Where("professional_id = ?", *professionalID)
        }</span>

        <span class="cov0" title="0">var total, completed int64
        if err := bookingQuery.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := bookingQuery.Where("status = ?", domain.BookingStatusDone).Count(&amp;completed).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">paymentQuery := s.dbWithContext(ctx).Model(&amp;domain.Payment{}).
                Where("tenant_id = ? AND paid_at &gt;= ? AND paid_at &lt; ?", tenantID, start, end)
        var rev struct {
                Total float64
        }
        if err := paymentQuery.Select("COALESCE(SUM(amount),0) as total").Scan(&amp;rev).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">revenue := rev.Total

        type result struct {
                ServiceID uuid.UUID
                Name      string
                Quantity  int64
        }
        var top []result
        err := s.dbWithContext(ctx).
                Table("sales_items").
                Select("sales_items.item_ref_id as service_id, services.name, SUM(sales_items.quantity) as quantity").
                Joins("JOIN sales_orders ON sales_orders.id = sales_items.order_id").
                Joins("JOIN services ON services.id = sales_items.item_ref_id").
                Where("sales_items.tenant_id = ? AND sales_items.item_type = ? AND sales_orders.created_at &gt;= ? AND sales_orders.created_at &lt; ?", tenantID, "service", start, end).
                Group("sales_items.item_ref_id, services.name").
                Order("quantity DESC").
                Limit(5).
                Scan(&amp;top).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">topServices := make([]TopService, len(top))
        for i, item := range top </span><span class="cov0" title="0">{
                topServices[i] = TopService{
                        ServiceID: item.ServiceID,
                        Name:      item.Name,
                        Quantity:  item.Quantity,
                }
        }</span>

        <span class="cov0" title="0">return &amp;DashboardDailyDTO{
                Date:        start.Format("2006-01-02"),
                Bookings:    total,
                Completed:   completed,
                Revenue:     revenue,
                TopServices: topServices,
        }, nil</span>
}
</pre>

		<pre class="file" id="file38" style="display: none">package service

import (
        "context"
        "errors"
        "time"

        "github.com/google/uuid"

        "github.com/kusmin/gestao_updev/backend/internal/domain"
)

// InventoryFilter para listagem.
type InventoryFilter struct {
        ProductID *uuid.UUID
        Type      string
        StartDate *time.Time
        EndDate   *time.Time
}

// InventoryInput para criação manual.
type InventoryInput struct {
        ProductID uuid.UUID
        OrderID   *uuid.UUID
        Type      string
        Quantity  int
        Reason    string
}

var ErrInvalidInventoryType = errors.New("tipo de movimentação inválido")

func (s *Service) ListInventoryMovements(ctx context.Context, tenantID uuid.UUID, filter InventoryFilter) ([]domain.InventoryMovement, error) <span class="cov0" title="0">{
        query := s.dbWithContext(ctx).
                Where("tenant_id = ?", tenantID)

        if filter.ProductID != nil </span><span class="cov0" title="0">{
                query = query.Where("product_id = ?", *filter.ProductID)
        }</span>
        <span class="cov0" title="0">if filter.Type != "" </span><span class="cov0" title="0">{
                query = query.Where("type = ?", filter.Type)
        }</span>
        <span class="cov0" title="0">if filter.StartDate != nil </span><span class="cov0" title="0">{
                query = query.Where("created_at &gt;= ?", *filter.StartDate)
        }</span>
        <span class="cov0" title="0">if filter.EndDate != nil </span><span class="cov0" title="0">{
                query = query.Where("created_at &lt;= ?", *filter.EndDate)
        }</span>

        <span class="cov0" title="0">var movements []domain.InventoryMovement
        if err := query.Order("created_at DESC").Find(&amp;movements).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return movements, nil</span>
}

func (s *Service) CreateInventoryMovement(ctx context.Context, tenantID uuid.UUID, input InventoryInput) (*domain.InventoryMovement, error) <span class="cov8" title="1">{
        if input.Quantity &lt;= 0 </span><span class="cov0" title="0">{
                return nil, errors.New("quantity must be greater than zero")
        }</span>

        <span class="cov8" title="1">switch input.Type </span>{
        case domain.InventoryMovementIn, domain.InventoryMovementOut, domain.InventoryMovementAdjustment:<span class="cov8" title="1"></span>
        default:<span class="cov0" title="0">
                return nil, ErrInvalidInventoryType</span>
        }
        <span class="cov8" title="1">if err := s.ensureTenantRecord(ctx, &amp;domain.Product{}, tenantID, input.ProductID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if input.OrderID != nil </span><span class="cov8" title="1">{
                if err := s.ensureTenantRecord(ctx, &amp;domain.SalesOrder{}, tenantID, *input.OrderID); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">movement := &amp;domain.InventoryMovement{
                TenantModel: domain.TenantModel{
                        TenantID: tenantID,
                },
                ProductID: input.ProductID,
                Type:      input.Type,
                Quantity:  input.Quantity,
                Reason:    input.Reason,
        }
        if input.OrderID != nil </span><span class="cov0" title="0">{
                movement.OrderID = input.OrderID
        }</span>

        <span class="cov0" title="0">if err := s.dbWithContext(ctx).Create(movement).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return movement, nil</span>
}
</pre>

		<pre class="file" id="file39" style="display: none">package service

import (
        "context"

        "github.com/google/uuid"

        "github.com/kusmin/gestao_updev/backend/internal/domain"
)

// ListProfessionals retorna profissionais ativos.
func (s *Service) ListProfessionals(ctx context.Context, tenantID uuid.UUID) ([]domain.Professional, error) <span class="cov0" title="0">{
        var professionals []domain.Professional
        if err := s.dbWithContext(ctx).
                Preload("Availability").
                Where("tenant_id = ? AND active = true", tenantID).
                Order("name ASC").
                Find(&amp;professionals).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return professionals, nil</span>
}
</pre>

		<pre class="file" id="file40" style="display: none">package service

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/google/uuid"
        "gorm.io/datatypes"
        "gorm.io/gorm"

        "github.com/kusmin/gestao_updev/backend/internal/domain"
)

// SalesOrderFilter filtros de listagem.
type SalesOrderFilter struct {
        Status   string
        ClientID *uuid.UUID
        Date     *time.Time
}

// SalesItemInput representa itens da venda.
type SalesItemInput struct {
        Type      string
        RefID     uuid.UUID
        Quantity  int
        UnitPrice float64
}

// SalesOrderInput payload de criação.
type SalesOrderInput struct {
        ClientID  uuid.UUID
        BookingID *uuid.UUID
        Items     []SalesItemInput
        Discount  float64
        Notes     string
}

// SalesOrderUpdateInput campos editáveis.
type SalesOrderUpdateInput struct {
        Status *string
        Notes  *string
}

// PaymentInput dados para registrar pagamentos.
type PaymentInput struct {
        Method  string
        Amount  float64
        PaidAt  time.Time
        Details map[string]interface{}
}

// PaymentFilter filtros de listagem de pagamentos.
type PaymentFilter struct {
        Method    string
        StartDate *time.Time
        EndDate   *time.Time
}

func (s *Service) ListSalesOrders(ctx context.Context, tenantID uuid.UUID, filter SalesOrderFilter) ([]domain.SalesOrder, error) <span class="cov0" title="0">{
        query := s.dbWithContext(ctx).
                Preload("Items").
                Where("tenant_id = ?", tenantID)

        if filter.Status != "" </span><span class="cov0" title="0">{
                query = query.Where("status = ?", filter.Status)
        }</span>
        <span class="cov0" title="0">if filter.ClientID != nil </span><span class="cov0" title="0">{
                query = query.Where("client_id = ?", *filter.ClientID)
        }</span>
        <span class="cov0" title="0">if filter.Date != nil </span><span class="cov0" title="0">{
                start := filter.Date.Truncate(24 * time.Hour)
                end := start.Add(24 * time.Hour)
                query = query.Where("created_at &gt;= ? AND created_at &lt; ?", start, end)
        }</span>

        <span class="cov0" title="0">var orders []domain.SalesOrder
        if err := query.Order("created_at DESC").Find(&amp;orders).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return orders, nil</span>
}

func (s *Service) CreateSalesOrder(ctx context.Context, tenantID uuid.UUID, input SalesOrderInput) (*domain.SalesOrder, error) <span class="cov8" title="1">{
        if len(input.Items) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("ao menos um item é obrigatório")
        }</span>
        <span class="cov8" title="1">if err := s.ensureTenantRecord(ctx, &amp;domain.Client{}, tenantID, input.ClientID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if input.BookingID != nil </span><span class="cov8" title="1">{
                if err := s.ensureTenantRecord(ctx, &amp;domain.Booking{}, tenantID, *input.BookingID); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">if err := s.ensureSalesItems(ctx, tenantID, input.Items); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">order := &amp;domain.SalesOrder{
                TenantModel: domain.TenantModel{
                        TenantID: tenantID,
                },
                ClientID: input.ClientID,
                Status:   domain.SalesOrderStatusDraft,
                Discount: input.Discount,
                Notes:    input.Notes,
        }
        if input.BookingID != nil </span><span class="cov0" title="0">{
                order.BookingID = input.BookingID
        }</span>

        <span class="cov0" title="0">err := s.repo.Transaction(ctx, func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                var total float64
                if err := tx.Create(order).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">for _, item := range input.Items </span><span class="cov0" title="0">{
                        if item.Quantity &lt;= 0 </span><span class="cov0" title="0">{
                                return errors.New("quantidade inválida em item")
                        }</span>
                        <span class="cov0" title="0">salesItem := domain.SalesItem{
                                TenantModel: domain.TenantModel{
                                        TenantID: tenantID,
                                },
                                OrderID:   order.ID,
                                ItemType:  item.Type,
                                ItemRefID: item.RefID,
                                Quantity:  item.Quantity,
                                UnitPrice: item.UnitPrice,
                        }
                        total += float64(item.Quantity) * item.UnitPrice
                        if err := tx.Create(&amp;salesItem).Error; err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov0" title="0">order.Total = total - input.Discount
                if order.Total &lt; 0 </span><span class="cov0" title="0">{
                        order.Total = 0
                }</span>
                <span class="cov0" title="0">return tx.Model(order).Updates(map[string]interface{}{"total": order.Total}).Error</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.dbWithContext(ctx).
                Preload("Items").
                First(order, "id = ?", order.ID).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return order, nil</span>
}

func (s *Service) UpdateSalesOrder(ctx context.Context, tenantID, orderID uuid.UUID, input SalesOrderUpdateInput) (*domain.SalesOrder, error) <span class="cov0" title="0">{
        var order domain.SalesOrder
        if err := s.dbWithContext(ctx).
                Where("tenant_id = ? AND id = ?", tenantID, orderID).
                Preload("Items").
                First(&amp;order).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">updates := map[string]interface{}{}
        if input.Status != nil </span><span class="cov0" title="0">{
                updates["status"] = *input.Status
        }</span>
        <span class="cov0" title="0">if input.Notes != nil </span><span class="cov0" title="0">{
                updates["notes"] = *input.Notes
        }</span>

        <span class="cov0" title="0">if len(updates) == 0 </span><span class="cov0" title="0">{
                return &amp;order, nil
        }</span>

        <span class="cov0" title="0">if err := s.dbWithContext(ctx).
                Model(&amp;domain.SalesOrder{}).
                Where("tenant_id = ? AND id = ?", tenantID, orderID).
                Updates(updates).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.dbWithContext(ctx).
                Where("tenant_id = ? AND id = ?", tenantID, orderID).
                Preload("Items").
                First(&amp;order).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;order, nil</span>
}

func (s *Service) AddPayment(ctx context.Context, tenantID, orderID uuid.UUID, input PaymentInput) (*domain.Payment, error) <span class="cov0" title="0">{
        if err := s.ensureTenantRecord(ctx, &amp;domain.SalesOrder{}, tenantID, orderID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">payment := &amp;domain.Payment{
                TenantModel: domain.TenantModel{
                        TenantID: tenantID,
                },
                OrderID: orderID,
                Method:  input.Method,
                Amount:  input.Amount,
                PaidAt:  input.PaidAt,
                Details: datatypes.JSONMap(input.Details),
        }
        if payment.Details == nil </span><span class="cov0" title="0">{
                payment.Details = datatypes.JSONMap{}
        }</span>

        <span class="cov0" title="0">if err := s.dbWithContext(ctx).Create(payment).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return payment, nil</span>
}

func (s *Service) ListPayments(ctx context.Context, tenantID uuid.UUID, filter PaymentFilter) ([]domain.Payment, error) <span class="cov0" title="0">{
        query := s.dbWithContext(ctx).
                Where("tenant_id = ?", tenantID)

        if filter.Method != "" </span><span class="cov0" title="0">{
                query = query.Where("method = ?", filter.Method)
        }</span>
        <span class="cov0" title="0">if filter.StartDate != nil </span><span class="cov0" title="0">{
                query = query.Where("paid_at &gt;= ?", *filter.StartDate)
        }</span>
        <span class="cov0" title="0">if filter.EndDate != nil </span><span class="cov0" title="0">{
                query = query.Where("paid_at &lt;= ?", *filter.EndDate)
        }</span>

        <span class="cov0" title="0">var payments []domain.Payment
        if err := query.Order("paid_at DESC").Find(&amp;payments).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return payments, nil</span>
}

func (s *Service) ensureSalesItems(ctx context.Context, tenantID uuid.UUID, items []SalesItemInput) error <span class="cov0" title="0">{
        for _, item := range items </span><span class="cov0" title="0">{
                switch item.Type </span>{
                case "service":<span class="cov0" title="0">
                        if err := s.ensureTenantRecord(ctx, &amp;domain.Service{}, tenantID, item.RefID); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                case "product":<span class="cov0" title="0">
                        if err := s.ensureTenantRecord(ctx, &amp;domain.Product{}, tenantID, item.RefID); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("tipo de item %q não suportado", item.Type)</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>

		<pre class="file" id="file41" style="display: none">package service

import (
        "context"
        "errors"
        "strings"

        "github.com/google/uuid"
        "go.uber.org/zap"
        "gorm.io/gorm"

        "github.com/kusmin/gestao_updev/backend/internal/auth"
        "github.com/kusmin/gestao_updev/backend/internal/config"
        "github.com/kusmin/gestao_updev/backend/internal/repository"
)

// ErrInvalidCredentials sinaliza falha de autenticação.
var ErrInvalidCredentials = errors.New("invalid credentials")

// Service agrega casos de uso de negócio.
type Service struct {
        repo   *repository.Repository
        jwt    *auth.JWTManager
        cfg    *config.Config
        logger *zap.Logger
}

// New instancia o service layer.
func New(cfg *config.Config, repo *repository.Repository, jwt *auth.JWTManager, logger *zap.Logger) *Service <span class="cov6" title="10">{
        return &amp;Service{
                repo:   repo,
                jwt:    jwt,
                cfg:    cfg,
                logger: logger,
        }
}</span>

func (s *Service) dbWithContext(ctx context.Context) *gorm.DB <span class="cov10" title="51">{
        return s.repo.DB().WithContext(ctx)
}</span>

func (s *Service) sanitizeEmail(email string) string <span class="cov6" title="9">{
        return strings.TrimSpace(strings.ToLower(email))
}</span>

func (s *Service) clampPagination(page, perPage int) (int, int) <span class="cov4" title="4">{
        if page &lt;= 0 </span><span class="cov2" title="2">{
                page = 1
        }</span>
        <span class="cov4" title="4">if perPage &lt;= 0 </span><span class="cov2" title="2">{
                perPage = 20
        }</span>
        <span class="cov4" title="4">if perPage &gt; 100 </span><span class="cov1" title="1">{
                perPage = 100
        }</span>
        <span class="cov4" title="4">return page, perPage</span>
}

func (s *Service) ensureTenantRecord(ctx context.Context, model interface{}, tenantID, recordID uuid.UUID) error <span class="cov4" title="5">{
        return s.dbWithContext(ctx).
                Model(model).
                Where("tenant_id = ? AND id = ?", tenantID, recordID).
                Take(model).Error
}</span>
</pre>

		<pre class="file" id="file42" style="display: none">package service

import (
        "context"

        "github.com/google/uuid"
        "golang.org/x/crypto/bcrypt"

        "github.com/kusmin/gestao_updev/backend/internal/domain"
)

// UsersFilter parametriza listagem.
type UsersFilter struct {
        Role    string
        Page    int
        PerPage int
}

// CreateUserInput contém dados obrigatórios/ opcionais.
type CreateUserInput struct {
        Name     string
        Email    string
        Password string
        Phone    string
        Role     string
}

// UpdateUserInput altera campos permitidos.
type UpdateUserInput struct {
        Name     *string
        Phone    *string
        Role     *string
        Active   *bool
        Password *string
}

// ListUsers retorna usuários do tenant com paginação.
func (s *Service) ListUsers(ctx context.Context, tenantID uuid.UUID, filter UsersFilter) ([]domain.User, int64, error) <span class="cov0" title="0">{
        var users []domain.User
        var total int64

        page, perPage := s.clampPagination(filter.Page, filter.PerPage)
        query := s.dbWithContext(ctx).Model(&amp;domain.User{}).
                Where("tenant_id = ?", tenantID)

        if filter.Role != "" </span><span class="cov0" title="0">{
                query = query.Where("role = ?", filter.Role)
        }</span>

        <span class="cov0" title="0">if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">if total == 0 </span><span class="cov0" title="0">{
                return []domain.User{}, 0, nil
        }</span>

        <span class="cov0" title="0">if err := query.
                Order("created_at DESC").
                Limit(perPage).
                Offset((page - 1) * perPage).
                Find(&amp;users).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return users, total, nil</span>
}

// ListAllUsers returns all users with pagination.
func (s *Service) ListAllUsers(ctx context.Context, filter UsersFilter) ([]domain.User, int64, er<span class="cov0" title="0">ror) {
        var users []domain.User
        var total int64

        page, perPage := s.clampPaginati</span>on(filter.Page, filter.PerPage)
        query := s.dbWithContext(ctx).Model(&amp;domain.User{})

        if filter.Role != "" </span></span>{
</span>                query = query.Where("role = ?", filter.Role)
        }</span>

        <span class="cov0" title="0">if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
</span>
        i</span>f total == 0 </span><span class="cov0" title="0">{
                return []domain.User{}, 0, nil
        }</span>

        if err := query.
                Order("created_at DESC").
                Limit(perPage).
                Offset((page - 1) * perPage).
                Find(&amp;users).Error; err != nil {
                return nil, 0, err
        }

        return users, total, nil
}

</span></span></span></span>
//</span> GetUser busca um usuário por ID.
f<span class="cov0" title="0">unc (s *Service)</span> GetUser(ctx context.Context, tenantID, userID uuid.UUID) (*domain.User, error) <span class="cov8" title="5">{
        var user domain.User
        if err := s.dbWithContext(ctx).
                Where("tenant_id = ? AND id = ?", tenantID, userID).
                First(&amp;user).Error; err != nil </span><span class="cov6" title="3">{
                return nil, err
        }</span>
        return &amp;user, nil
}
</span></span>
//</span> CreateUser adiciona um novo colaborador ao tenant.
func (s *Service) CreateUser(ctx context.Context, tenantID uuid.UUID, input CreateUserInput) (*domain.User, error) <span class="cov10" title="7">{
        passwordHash, err := bcrypt.GenerateFromPassword([]byte(input.Password), s.cfg.BcryptCost)
        if err != nil </span>{
</span>                return nil, err
        }</span></span>

</span>        user := &amp;domain.User{
                </span>TenantModel: domain.TenantModel{
                        TenantID: tenantID,
                },
                Name:         input.Name,
                Email:        s.sanitizeEmail(input.Email),
                Phone:        input.Phone,
                Role:         input.Role,
                PasswordHash: string(passwordHash),
                Active:       true,
        }

        if err := s.dbWithContext(ctx).Create(user).Error; err != nil </span></span></span></span></span></span></span>{
</span>                return nil, err
        }</span></span>
        <span class="cov9" title="6">return user, nil</span>
}<span class="cov0" title="0">
</span>
//</span> UpdateUser altera campos selecionados de um usuário existente.
func (s *Service) UpdateUser(ctx context.Context, tenantID, userID uuid.UUID, input UpdateUserInput) (*domain.User, error) <span class="cov1" title="1">{
        var user domain.User
        if err := s.dbWithContext(ctx).
                Where("tenant_id = ? AND id = ?", tenantID, userID).
                First(&amp;user).Error; err != nil </span>{
</span>                return nil, err
        }</span></span>

        <span class="cov0" title="0">updates := map[string]interface{}{}
        if input.Name != nil </span>{
                updates["name"] = *input.Name
</span></span></span>        }</span>
        i</span>f input.Phone != nil </span><span class="cov0" title="0">{
                updates["phone"] = *input.Phone
        }</span>
</span>        <span class="cov1" title="1">if input.Role != nil </span><span class="cov0" title="0">{
                updates["role"] = *input.Role
        }</span>
        <span class="cov1" title="1">if input.Active != nil </span><span class="cov0" title="0">{
                updates["active"] = *input.Active
        }</span>
        if input.Password != nil &amp;&amp; *input.Password != "" {
        </span></span>        hash, err := bcrypt.GenerateFromPassword([]byte(*input.Password), s.cfg.BcryptCost)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">updates["password_hash"] = string(hash)</span>
        }

        <span class="cov1" title="1">if len(updates) == 0 </span><span class="cov0" title="0">{
                return &amp;user, nil
        }</span>

        <span class="cov1" title="1">if err := s.dbWithContext(ctx).
                Model(&amp;domain.User{}).
                Where("tenant_id = ? AND id = ?", tenantID, userID).
                Updates(updates).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if err := s.dbWithContext(ctx).
                Where("tenant_id = ? AND id = ?", tenantID, userID).
                First(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return &amp;user, nil</span>
}

// DeleteUser realiza soft delete do usuário.
func (s *Service) DeleteUser(ctx context.Context, tenantID, userID uuid.UUID) error <span class="cov1" title="1">{
        return s.dbWithContext(ctx).
                Where("tenant_id = ? AND id = ?", tenantID, userID).
                Delete(&amp;domain.User{}).Error
}</span>

// AdminCreateUser adds a new user to a specific tenant.
func (s *Service) AdminCreateUser(ctx context.Context, input CreateUserInput, tenantID uuid.UUID) (*domain.User, error) <span class="cov0" title="0">{
        passwordHash, err := bcrypt.GenerateFromPassword([]byte(input.Password), s.cfg.BcryptCost)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">user := &amp;domain.User{
                TenantModel: domain.TenantModel{
                        TenantID: tenantID,
                },
                Name:         input.Name,
                Email:        s.sanitizeEmail(input.Email),
                Phone:        input.Phone,
                Role:         input.Role,
                PasswordHash: string(passwordHash),
                Active:       true,
        }

        if err := s.dbWithContext(ctx).Create(user).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return user, nil</span>
}

// AdminUpdateUser updates selected fields of an existing user.
func (s *Service) AdminUpdateUser(ctx context.Context, userID uuid.UUID, input UpdateUserInput) (*domain.User, error) <span class="cov0" title="0">{
        var user domain.User
        if err := s.dbWithContext(ctx).First(&amp;user, "id = ?", userID).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">updates := map[string]interface{}{}
        if input.Name != nil </span><span class="cov0" title="0">{
                updates["name"] = *input.Name
        }</span>
        <span class="cov0" title="0">if input.Phone != nil </span><span class="cov0" title="0">{
                updates["phone"] = *input.Phone
        }</span>
        <span class="cov0" title="0">if input.Role != nil </span><span class="cov0" title="0">{
                updates["role"] = *input.Role
        }</span>
        <span class="cov0" title="0">if input.Active != nil </span><span class="cov0" title="0">{
                updates["active"] = *input.Active
        }</span>
        <span class="cov0" title="0">if input.Password != nil &amp;&amp; *input.Password != "" </span><span class="cov0" title="0">{
                hash, err := bcrypt.GenerateFromPassword([]byte(*input.Password), s.cfg.BcryptCost)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">updates["password_hash"] = string(hash)</span>
        }

        <span class="cov0" title="0">if len(updates) == 0 </span><span class="cov0" title="0">{
                return &amp;user, nil
        }</span>

        <span class="cov0" title="0">if err := s.dbWithContext(ctx).
                Model(&amp;domain.User{}).
                Where("id = ?", userID).
                Updates(updates).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.dbWithContext(ctx).First(&amp;user, "id = ?", userID).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;user, nil</span>
}

// AdminDeleteUser soft deletes a user.
func (s *Service) AdminDeleteUser(ctx context.Context, userID uuid.UUID) error <span class="cov0" title="0">{
        return s.dbWithContext(ctx).Delete(&amp;domain.User{}, "id = ?", userID).Error
}</span>

</pre>

		<pre class="file" id="file43" style="display: none">package database

import (
        "fmt"
        "time"

        "gorm.io/driver/postgres"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"
)

// Config encapsula parâmetros do pool de conexão.
type Config struct {
        URL             string
        MaxIdleConns    int
        MaxOpenConns    int
        ConnMaxLifetime time.Duration
        LogMode         logger.LogLevel
}

// New cria uma instância do GORM conectada ao PostgreSQL.
func New(cfg Config) (*gorm.DB, error) <span class="cov0" title="0">{
        if cfg.URL == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("database url is required")
        }</span>

        <span class="cov0" title="0">gormCfg := &amp;gorm.Config{
                Logger: logger.Default.LogMode(cfg.LogMode),
        }

        db, err := gorm.Open(postgres.Open(cfg.URL), gormCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("open postgres connection: %w", err)
        }</span>

        <span class="cov0" title="0">sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("extract sql.DB: %w", err)
        }</span>

        <span class="cov0" title="0">if cfg.MaxIdleConns &gt; 0 </span><span class="cov0" title="0">{
                sqlDB.SetMaxIdleConns(cfg.MaxIdleConns)
        }</span>
        <span class="cov0" title="0">if cfg.MaxOpenConns &gt; 0 </span><span class="cov0" title="0">{
                sqlDB.SetMaxOpenConns(cfg.MaxOpenConns)
        }</span>
        <span class="cov0" title="0">if cfg.ConnMaxLifetime &gt; 0 </span><span class="cov0" title="0">{
                sqlDB.SetConnMaxLifetime(cfg.ConnMaxLifetime)
        }</span>

        <span class="cov0" title="0">return db, nil</span>
}
</pre>

		<pre class="file" id="file44" style="display: none">package logger

import (
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

// New cria um logger configurado para ambientes de API.
func New(level string) (*zap.Logger, error) <span class="cov10" title="3">{
        cfg := zap.NewProductionConfig()
        if level != "" </span><span class="cov6" title="2">{
                if err := cfg.Level.UnmarshalText([]byte(level)); err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>
        }
        <span class="cov6" title="2">cfg.EncoderConfig.TimeKey = "timestamp"
        cfg.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
        return cfg.Build()</span>
}
</pre>

		<pre class="file" id="file45" style="display: none">package telemetry

import (
        "context"
        "errors"
        "fmt"
        "net/http"
        "strings"

        "github.com/prometheus/client_golang/prometheus/promhttp"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp"
        "go.opentelemetry.io/otel/exporters/prometheus"
        "go.opentelemetry.io/otel/propagation"
        "go.opentelemetry.io/otel/sdk/metric"
        "go.opentelemetry.io/otel/sdk/resource"
        sdktrace "go.opentelemetry.io/otel/sdk/trace"
        semconv "go.opentelemetry.io/otel/semconv/v1.26.0"
)

// Config define parâmetros de inicialização da telemetria.
type Config struct {
        ServiceName    string
        ServiceVersion string
        Environment    string
        EnableTracing  bool
        OTLPEndpoint   string
        OTLPHeaders    string
        OTLPInsecure   bool
}

// Telemetry encapsula providers e exportadores.
type Telemetry struct {
        tracerProvider *sdktrace.TracerProvider
        meterProvider  *metric.MeterProvider
        promExporter   *prometheus.Exporter
}

// Init configura tracer/meter providers e exportadores.
func Init(ctx context.Context, cfg Config) (*Telemetry, error) <span class="cov0" title="0">{
        res, err := resource.New(
                ctx,
                resource.WithFromEnv(),
                resource.WithProcess(),
                resource.WithOS(),
                resource.WithTelemetrySDK(),
                resource.WithAttributes(resourceAttributes(cfg)...),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("build otel resource: %w", err)
        }</span>

        <span class="cov0" title="0">promExporter, meterProvider, err := initPrometheusProvider(res)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("init prometheus exporter: %w", err)
        }</span>

        <span class="cov0" title="0">tracerProvider, err := initTracerProvider(ctx, res, cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">otel.SetTracerProvider(tracerProvider)
        otel.SetMeterProvider(meterProvider)
        otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
                propagation.TraceContext{},
                propagation.Baggage{},
        ))

        return &amp;Telemetry{
                tracerProvider: tracerProvider,
                meterProvider:  meterProvider,
                promExporter:   promExporter,
        }, nil</span>
}

// Shutdown encerra providers e exportadores.
func (t *Telemetry) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        var err error
        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if t.meterProvider != nil </span><span class="cov0" title="0">{
                err = errors.Join(err, t.meterProvider.Shutdown(ctx))
        }</span>
        <span class="cov0" title="0">if t.tracerProvider != nil </span><span class="cov0" title="0">{
                err = errors.Join(err, t.tracerProvider.Shutdown(ctx))
        }</span>
        <span class="cov0" title="0">return err</span>
}

// TracerProvider expõe o provider de tracing.
func (t *Telemetry) TracerProvider() *sdktrace.TracerProvider <span class="cov0" title="0">{
        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return t.tracerProvider</span>
}

// MeterProvider expõe o provider de métricas.
func (t *Telemetry) MeterProvider() *metric.MeterProvider <span class="cov0" title="0">{
        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return t.meterProvider</span>
}

// MetricsHandler retorna o handler HTTP para /metrics.
func (t *Telemetry) MetricsHandler() http.Handler <span class="cov0" title="0">{
        if t == nil || t.promExporter == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return promhttp.Handler()</span>
}

func initPrometheusProvider(res *resource.Resource) (*prometheus.Exporter, *metric.MeterProvider, error) <span class="cov0" title="0">{
        exporter, err := prometheus.New(prometheus.WithoutScopeInfo())
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">meterProvider := metric.NewMeterProvider(
                metric.WithReader(exporter),
                metric.WithResource(res),
        )
        return exporter, meterProvider, nil</span>
}

func initTracerProvider(ctx context.Context, res *resource.Resource, cfg Config) (*sdktrace.TracerProvider, error) <span class="cov0" title="0">{
        if cfg.EnableTracing &amp;&amp; cfg.OTLPEndpoint != "" </span><span class="cov0" title="0">{
                client := otlptracehttp.NewClient(
                        otlptracehttp.WithEndpoint(cfg.OTLPEndpoint),
                        otlptracehttp.WithURLPath("v1/traces"),
                        otlptracehttp.WithHeaders(parseHeaders(cfg.OTLPHeaders)),
                )
                if cfg.OTLPInsecure </span><span class="cov0" title="0">{
                        client = otlptracehttp.NewClient(
                                otlptracehttp.WithEndpoint(cfg.OTLPEndpoint),
                                otlptracehttp.WithInsecure(),
                                otlptracehttp.WithURLPath("v1/traces"),
                                otlptracehttp.WithHeaders(parseHeaders(cfg.OTLPHeaders)),
                        )
                }</span>
                <span class="cov0" title="0">exporter, err := otlptrace.New(ctx, client)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("init otlp exporter: %w", err)
                }</span>
                <span class="cov0" title="0">return sdktrace.NewTracerProvider(
                        sdktrace.WithBatcher(exporter),
                        sdktrace.WithResource(res),
                ), nil</span>
        }

        <span class="cov0" title="0">return sdktrace.NewTracerProvider(
                sdktrace.WithSampler(sdktrace.AlwaysSample()),
                sdktrace.WithResource(res),
        ), nil</span>
}

func resourceAttributes(cfg Config) []attribute.KeyValue <span class="cov0" title="0">{
        attrs := []attribute.KeyValue{
                semconv.ServiceName(cfg.ServiceName),
                attribute.String("deployment.environment", cfg.Environment),
        }
        if cfg.ServiceVersion != "" </span><span class="cov0" title="0">{
                attrs = append(attrs, semconv.ServiceVersion(cfg.ServiceVersion))
        }</span>
        <span class="cov0" title="0">return attrs</span>
}

func parseHeaders(raw string) map[string]string <span class="cov0" title="0">{
        headers := map[string]string{}
        if raw == "" </span><span class="cov0" title="0">{
                return headers
        }</span>
        <span class="cov0" title="0">pairs := strings.Split(raw, ",")
        for _, pair := range pairs </span><span class="cov0" title="0">{
                parts := strings.SplitN(strings.TrimSpace(pair), "=", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">headers[strings.TrimSpace(parts[0])] = strings.TrimSpace(parts[1])</span>
        }
        <span class="cov0" title="0">return headers</span>
}
</pre>

		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
